import os
import time
import re
from typing import Sequence
import abc

import numpy as np
import uuid

from app.model import files, services
from app.model.files import File


class PersistentObject(abc.ABC):
    class MinimalObject(dict):
        def __init__(self, object_type, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.type = object_type

    @abc.abstractmethod
    def get_persistent_data(self) -> MinimalObject:
        pass

    @staticmethod
    @abc.abstractmethod
    def build_from_persistent_data(data: MinimalObject):
        pass

    def _recursive_build(self, **kwargs):  # FIXME make this actually recursive. Then make a builder :evil smile:
        minimal_dictionary = {}

        for constructor_name, attribute in kwargs.items():
            if isinstance(attribute, PersistentObject):
                minimal_dictionary[constructor_name] = attribute.get_persistent_data()
            elif isinstance(attribute, list):
                minimal_dictionary[constructor_name] = [
                    a if not isinstance(a, PersistentObject) else a.get_persistent_data() for a in attribute
                ]
            elif isinstance(attribute, dict):
                minimal_dictionary[constructor_name] = {
                    k: a if not isinstance(a, PersistentObject) else a.get_persistent_data() for k, a in
                    attribute.items()
                }
            else:
                minimal_dictionary[constructor_name] = attribute

        return self.MinimalObject(str(type(self)), minimal_dictionary)


class Histogram(np.ndarray, PersistentObject):
    """
    A class to represent a histogram. Inherits a numpy array so we can perform numpy
    operations on it along with storing custom methods and attributes.
    
    ...

    Attributes
    ----------
    id : str
        Id of the run associated with this histogram (generated by beams, not in .dat file).
    time_zero : int
        Bin at which the clock starts.
    good_bin_start : int
        First bin that could be used in calculating asymmetry.
    good_bin_end : int
        Last bin that could be used in calculating asymmetry.
    background_start : int
        First bin that could be used in calculating background radiation.
    background_end : int
        Last bin that could be used in calculating background radiation.
    bin_size : float
        Time (ns) per bin.
    title: string
        Title of the histogram (e.g. 'Forw', 'Back' etc).

    Methods
    -------
    intersect(other)
        Finds the intersection of two histograms.
    background_radiation()
        Finds the background radiation of the histogram.
    combine(other)
        Combines this histogram with another histogram (returns new histogram).
    
    """

    def __new__(cls, input_array, time_zero, good_bin_start, good_bin_end,
                background_start, background_end, title, run_id, bin_size, **kwargs):
        """ Initializes a new Histogram.

        Parameters
        ----------
        input_array : Iterable
            Full histogram.
        time_zero : int
            Bin at which the clock starts
        good_bin_start : int
            First bin that could be used in calculating asymmetry.
        good_bin_end : int
            Last bin that could be used in calculating asymmetry.
        background_start : int
            First bin that could be used in calculating background radiation.
        background_end : int
            Last bin that could be used in calculating background radiation.
        run_id : str
            Id of the run associated with this histogram (generated by beams, not in .dat file).
        bin_size : float
            Time (ns) per bin.
        title: string
            Title of the histogram (e.g. 'Forw', 'Back' etc).

        Returns
        -------
        self : Histogram
            A shiny new Histogram!
        
        """

        self = np.asarray(input_array).view(cls)
        self.id = run_id
        self.time_zero = int(time_zero)
        self.good_bin_start = int(good_bin_start)
        self.good_bin_end = int(good_bin_end)
        self.background_start = int(background_start)
        self.background_end = int(background_end)
        self.bin_size = float(bin_size)
        self.title = title

        return self

    def get_persistent_data(self):
        return self._recursive_build(
            input_array=list(self),
            run_id=self.id,
            time_zero=self.time_zero,
            good_bin_start=self.good_bin_start,
            good_bin_end=self.good_bin_end,
            background_start=self.background_start,
            background_end=self.background_end,
            bin_size=self.bin_size,
            title=self.title
        )

    @staticmethod
    def build_from_persistent_data(data):
        return None if data is None else Histogram(**data)

    def __repr__(self):
        return f'Histogram({repr(super)}, {self.title}, {self.time_zero}, {self.good_bin_start}, ' \
               f'{self.good_bin_end}, {self.background_start}, {self.background_end}, {self.bin_size}, {self.id})'

    def __eq__(self, other):
        return self.time_zero == other.time_zero and \
               self.good_bin_start == other.good_bin_start and \
               self.good_bin_end == other.good_bin_end and \
               self.background_start == other.background_start and \
               self.background_end == other.background_end and \
               self.bin_size == other.bin_size and \
               self.title == other.title and \
               np.array_equal(self, other)

    def __reduce__(self):
        pickled_state = super(Histogram, self).__reduce__()

        new_state = pickled_state[2] + (self.__dict__,)

        return pickled_state[0], pickled_state[1], new_state

    def __setstate__(self, state, **kwargs):
        self.__dict__.update(state[-1])
        super(Histogram, self).__setstate__(state[0:-1])

    def __array_finalize__(self, obj):
        if obj is None:
            return

        self.id = getattr(obj, 'id', None)
        self.time_zero = getattr(obj, 'time_zero', None)
        self.good_bin_start = getattr(obj, 'good_bin_start', None)
        self.good_bin_end = getattr(obj, 'good_bin_end', None)
        self.background_start = getattr(obj, 'background_start', None)
        self.background_end = getattr(obj, 'background_end', None)
        self.bin_size = getattr(obj, 'bin_size', None)
        self.title = getattr(obj, 'title', None)

    def intersect(self, other):
        """ Finds useable intersection of two histograms.

        Two histograms we want to calculate asymmetries from may have different time_zero bins,
        or different good_bin ranges (the range that can be used for calculating the asymmetry)
        so this function finds the largest range of bins that can be used for calculating the
        asymmetry and the new time_zero.

        Parameters
        ----------
        other : Histogram
            The histogram we are finding an intersection with.

        Returns
        -------
        start_bin_one : int
            The first bin that can be used in calculating the asymmetry with the first histogram.
        start_bin_two : int
            The first bin that can be used in calculating the asymmetry with the second histogram.
        end_bin_one : int
            The last bin that can be used in calculating the asymmetry with the first histogram.
        end_bin_two : int
            The last bin that can be used in calculating the asymmetry with the second histogram.
        init_dif : int
            New adjusted time zero for the asymmetry. Difference in bins between time zero, and good bin start.

        """
        t_one = int(self.time_zero)
        t_two = int(other.time_zero)
        start_one = int(self.good_bin_start)
        start_two = int(other.good_bin_start)
        end_one = int(self.good_bin_end)
        end_two = int(other.good_bin_end)

        if (start_one > end_one) or (start_two > end_two) or \
                (start_one < 0) or (start_two < 0) or \
                (end_one > len(self)) or (end_two > len(self)):
            raise ValueError("Invalid range for calculating asymmetry ({}: {}->{}, {}: {}->{})".format(self.title,
                                                                                                       start_one,
                                                                                                       end_one,
                                                                                                       other.title,
                                                                                                       start_two,
                                                                                                       end_two))
        dif_one = start_one - t_one
        dif_two = start_two - t_two

        init_dif = dif_one if dif_one > dif_two else dif_two
        start_bin_one = t_one + init_dif
        start_bin_two = t_two + init_dif

        num_good_one = end_one - start_bin_one
        num_good_two = end_two - start_bin_two

        num_cross_good = num_good_one if num_good_one < num_good_two else num_good_two
        end_bin_one = start_bin_one + num_cross_good
        end_bin_two = start_bin_two + num_cross_good

        return start_bin_one, start_bin_two, end_bin_one, end_bin_two, init_dif

    def background_radiation(self):
        """ Calculates background radiation of histogram.

        Calculates based on the range indicated by the background_start and background_end
        attributes.

        Returns
        -------
        float : Background radiation.

        Raises
        ------
        ValueError : self.background_start and self.background_end result in an invalid range for background.
        """
        if (self.background_start > self.background_end) or \
                (self.background_start < 0) or \
                (self.background_end > len(self)):
            raise ValueError("Invalid range for calculating background radiation ({}->{})".format(self.background_start,
                                                                                                  self.background_end))
        return float(np.mean(self[int(self.background_start):int(self.background_end) + 1]))

    @staticmethod
    def combine(histograms: Sequence['Histogram']) -> 'Histogram':
        """ Combines two or more histograms and returns the resulting Histogram.

        Does not alter the histogram objects being combined.

        Parameters
        ----------
        histograms : *Histograms
            The histgram(s) to be combined.

        Returns
        -------
        Histogram : The resulting combined histogram.

        for histogram in other:
            histogram.time_zero

        take the later background-starts, earlier background_end

        np_array1 + np_array2
        hist1 + hist2

        new_histogram = Histogram

        """
        if len(histograms) < 2:
            raise ValueError("At least 2 histograms must be provided to be combined.")

        h1 = histograms[0]
        for i in range(1, len(histograms)):
            h = histograms[i]
            if h1.bin_size != h.bin_size:
                raise ValueError("Bin sizes must be the same on all histograms to be combined")
            if h1.title != h.title:
                raise ValueError("Histogram titles must match to be combined")

        time_zeroes = [h.time_zero for h in histograms]
        time_zero_shortest = min(time_zeroes)
        time_zero_furthest = max(time_zeroes)

        final_hist = None
        good_bins_start = []
        good_bins_end = []
        background_bins_start = []
        background_bins_end = []

        for histogram in histograms:
            our_time_zero = histogram.time_zero
            time_zero_difference_front = our_time_zero - time_zero_shortest
            time_zero_difference_back = our_time_zero - time_zero_furthest

            if final_hist is None:
                final_hist = np.array(histogram[time_zero_difference_front:time_zero_difference_back]) if \
                    time_zero_difference_back else histogram[time_zero_difference_front:]
            else:
                final_hist += histogram[time_zero_difference_front:time_zero_difference_back] if \
                    time_zero_difference_back else histogram[time_zero_difference_front:]

            good_bins_start.append(histogram.good_bin_start - time_zero_difference_front)
            good_bins_end.append(histogram.good_bin_end - time_zero_difference_front)
            background_bins_start.append(histogram.background_start - time_zero_difference_front)
            background_bins_end.append(histogram.background_end - time_zero_difference_front)

        new_t0 = time_zero_shortest
        new_good_bin_start = max(good_bins_start)
        new_good_bin_end = min(good_bins_end)
        new_bkgd_start = max(background_bins_start)
        new_bkgd_end = min(background_bins_end)

        new_bin_size = histograms[0].bin_size
        new_title = histograms[0].title

        new_histogram = Histogram(final_hist, new_t0, new_good_bin_start, new_good_bin_end,
                                  new_bkgd_start, new_bkgd_end, new_title, "none", new_bin_size)
        return new_histogram


class Asymmetry(np.ndarray, PersistentObject):
    """
    A class to represent an asymmetry of two histograms with the corresponding attributes. Inherits from numpy.ndarray
    so we can perform numpy calculations on it with casting it to an numpy array.

    ...

    Attributes
    ----------
    bin_size : float
        Time (ns) per bin.
    time_zero : float
        Bin at which the clock starts.
    alpha : float
        Alpha for correcting the run. Alpha should match the alpha of the actual asymmetry, not set without correcting.
    time : Time
        Time object (inherits from np.ndarray).
    uncertainty : Uncertainty
        Uncertainty object (inherits from np.ndarray).

    Methods
    -------
    bin(packing)
        Returns a new asymmetry binned to the provided value.
    correct(alpha)
        Returns a new asymmetry corrected to the provided value.
    raw()
        Returns a new asymmetry where alpha is equal to 1.
    cut(min_time, max_time)
        Returns a new asymmetry between the specified times.
    """

    def get_persistent_data(self):
        return self._recursive_build(
            input_array=list(self),
            time_zero=self.time_zero,
            bin_size=self.bin_size,
            uncertainty=list(self.uncertainty),
            time=list(self.time),
            alpha=self.alpha,
            calculated=self.calculated
        )

    @staticmethod
    def build_from_persistent_data(data):
        return None if data is None else Asymmetry(**data)

    def __new__(cls, input_array=None, time_zero=None, bin_size=None, histogram_one=None, histogram_two=None,
                uncertainty=None, time=None, alpha=None, calculated=None, **kwargs):
        """ Initializes a new Asymmetry.

        Parameters
        ----------
        FIRST CONSTRUCTOR OPTIONS
            input_array : Iterable
                Precalculated asymmetry.
            time_zero : int
                Bin at which the clock starts.
            bin_size : float
                Time (ns) per bin.
            uncertainty : Iterable
                Precalculated uncertainty.
            time : Iterable
                Precalculated time.

        SECOND CONSTRUCTOR OPTIONS
            histogram_one, histogram_two : Histogram
                Histograms to be used in calculating the new asymmetry.

        OPTIONAL
            alpha : float
                Alpha value to correct the asymmetry after it is calculated.
        """
        if (input_array is None or time_zero is None or bin_size is None or uncertainty is None or time is None) \
                and (histogram_one is None or histogram_two is None):
            raise ValueError("Not enough constructor parameters satisfied")

        if input_array is None:
            start_bin_one, start_bin_two, end_bin_one, end_bin_two, time_zero = histogram_one.intersect(histogram_two)
            background_one = histogram_one.background_radiation()
            background_two = histogram_two.background_radiation()
            histogram_one_good = histogram_one[start_bin_one - 1: end_bin_one]
            histogram_two_good = histogram_two[start_bin_two - 1: end_bin_two]
            input_array = ((histogram_one_good - background_one) - (histogram_two_good - background_two)) / \
                          ((histogram_two_good - background_two) + (histogram_one_good - background_one))

            if alpha is not None:
                input_array = ((alpha - 1) + ((alpha + 1) * input_array)) / \
                              ((alpha + 1) + ((alpha - 1) * input_array))

            if histogram_one.bin_size != histogram_two.bin_size:
                raise ValueError("Histograms do not have the same bin size")
            bin_size = histogram_one.bin_size

        if uncertainty is None:
            uncertainty = Uncertainty(histogram_one=histogram_one, histogram_two=histogram_two)
        else:
            uncertainty = Uncertainty(input_array=uncertainty, bin_size=bin_size)

        if time is None:
            time = Time(bin_size_ns=bin_size, length=len(input_array), time_zero_bin=time_zero)
        else:
            time = Time(input_array=time, bin_size_ns=bin_size, length=len(input_array), time_zero_bin=time_zero)

        self = np.asarray(input_array).view(cls)
        self.calculated = calculated
        self.uncertainty = uncertainty
        self.time = time
        self.bin_size = float(bin_size)
        self.time_zero = int(time_zero)
        self.alpha = alpha if alpha is not None else 1

        return self

    def __eq__(self, other):
        return self.bin_size == other.bin_size and \
               self.time_zero == other.time_zero and \
               self.alpha == other.alpha and \
               np.array_equal(self, other) and \
               np.array_equal(self.time, other.time) and \
               np.array_equal(self.uncertainty, other.uncertainty)

    def __repr__(self):
        return f'Asymmetry({repr(super)}, {repr(self.calculated)}, {repr(self.uncertainty)}, {repr(self.time)}' \
               f'{self.bin_size}, {self.time_zero}, {self.alpha})'

    def __reduce__(self):
        pickled_state = super(Asymmetry, self).__reduce__()

        new_state = pickled_state[2] + (self.__dict__,)

        return pickled_state[0], pickled_state[1], new_state

    def __setstate__(self, state, **kwargs):
        self.__dict__.update(state[-1])
        super(Asymmetry, self).__setstate__(state[0:-1])

    def __array_finalize__(self, obj):
        if obj is None:
            return

        self.calculated = getattr(obj, 'calculated', None)
        self.uncertainty = getattr(obj, 'uncertainty', None)
        self.time = getattr(obj, 'time', None)
        self.bin_size = getattr(obj, 'bin_size', None)
        self.time_zero = getattr(obj, 'time_zero', None)
        self.alpha = getattr(obj, 'alpha', None)

    @classmethod
    def from_array(cls):
        raise NotImplementedError()

    @classmethod
    def from_histogram(cls):
        raise NotImplementedError()

    def bin(self, packing):
        """ Returns new asymmetry binned to the provided packing value.

        Does not alter asymmetry object.

        Parameters
        ----------
        packing : float
            Value (in nanoseconds) to bin the asymmetry to.

        Returns
        -------
        asymmetry: Asymmetry
            A new asymmetry object binned to the provided value.

        Raises
        ------
        ValueError : Packing is a value less then 0 OR would result in an asymmetry with no elements.
        """
        if packing < 0:
            raise ValueError("Bin size must be a positive value (got {}ns)".format(packing))

        bin_full = self.bin_size / 1000
        bin_binned = float(packing) / 1000
        num_bins = len(self)

        if bin_binned <= bin_full:
            return Asymmetry(input_array=self, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time.bin(packing), uncertainty=self.uncertainty.bin(packing), alpha=self.alpha,
                             calculated=self.calculated)

        binned_indices_per_bin = int(np.round(bin_binned / bin_full))
        binned_indices_total = int(np.floor(num_bins / binned_indices_per_bin))
        leftover_bins = int(num_bins % binned_indices_per_bin)

        if leftover_bins:
            reshaped_asymmetry = np.reshape(self[:-leftover_bins],
                                            (binned_indices_total, binned_indices_per_bin))
        else:
            reshaped_asymmetry = np.reshape(self, (binned_indices_total, binned_indices_per_bin))

        try:
            binned_asymmetry = np.apply_along_axis(np.mean, 1, reshaped_asymmetry)
        except ValueError:
            raise ValueError("Invalid bin size for asymmetry ({}ns)".format(packing))

        if self.calculated is not None:
            if leftover_bins:
                reshaped_calculated = np.reshape(self.calculated[:-leftover_bins],
                                                 (binned_indices_total, binned_indices_per_bin))
            else:
                reshaped_calculated = np.reshape(self.calculated, (binned_indices_total, binned_indices_per_bin))

            binned_calculated = np.apply_along_axis(np.mean, 1, reshaped_calculated)

            return Asymmetry(input_array=binned_asymmetry, time_zero=self.time_zero, bin_size=packing,
                             time=self.time.bin(packing), uncertainty=self.uncertainty.bin(packing), alpha=self.alpha,
                             calculated=binned_calculated)
        else:
            return Asymmetry(input_array=binned_asymmetry, time_zero=self.time_zero, bin_size=packing,
                             time=self.time.bin(packing), uncertainty=self.uncertainty.bin(packing), alpha=self.alpha,
                             calculated=self.calculated)

    def correct(self, alpha):
        """ Returns a new asymmetry corrected to the provided value.

        Does not alter the asymmetry object. Asymmetry is first correct back to a value of 1 before being corrected
        to the provided value. If alpha of asymmetry is already equal to provided value, the current asymmetry object
        is returned.

        Parameters
        ----------
        alpha : float
            Alpha value to correct the current asymmetry to.

        Returns
        -------
        asymmetry : Asymmetry
            A new asymmetry object corrected to the provided value.
        """
        alpha = float(alpha)

        if self.alpha == alpha:
            return Asymmetry(input_array=self, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time, uncertainty=self.uncertainty, alpha=alpha, calculated=self.calculated)

        current_asymmetry = self

        if self.alpha != 1:
            current_asymmetry = self.raw()

        input_array = ((alpha - 1) + ((alpha + 1) * current_asymmetry)) / \
                      ((alpha + 1) + ((alpha - 1) * current_asymmetry))

        if self.calculated is not None:
            calculated = ((alpha - 1) + ((alpha + 1) * self.calculated)) / \
                         ((alpha + 1) + ((alpha - 1) * self.calculated))

            return Asymmetry(input_array=input_array, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time, uncertainty=self.uncertainty, alpha=alpha, calculated=calculated)
        else:
            return Asymmetry(input_array=input_array, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time, uncertainty=self.uncertainty, alpha=alpha, calculated=self.calculated)

    def raw(self):
        """ Returns a new asymmetry corrected (or uncorrected) to a value of 1.

        Does not alter the current asymmetry object. If alpha of asymmetry is already 1, the current asymmetry object
        is returned.

        Returns
        -------
        asymmetry : Asymmetry
            A new asymmetry object corrected to a value of 1.
        """
        if self.alpha == 1:
            return Asymmetry(input_array=self, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time, uncertainty=self.uncertainty, alpha=1, calculated=self.calculated)

        input_array = ((1 - self.alpha) + (1 + self.alpha) * self) / \
                      ((1 + self.alpha) + (1 - self.alpha) * self)

        if self.calculated is not None:
            calculated = ((1 - self.calculated) + (1 + self.calculated) * self) / \
                         ((1 + self.calculated) + (1 - self.calculated) * self)

            return Asymmetry(input_array=input_array, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time, uncertainty=self.uncertainty, alpha=1, calculated=calculated)
        else:
            return Asymmetry(input_array=input_array, time_zero=self.time_zero, bin_size=self.bin_size,
                             time=self.time, uncertainty=self.uncertainty, alpha=1, calculated=self.calculated)

    def cut(self, min_time=None, max_time=None):
        """ Returns a new asymmetry cut between the specified times.

        Does not alter the current asymmetry object. Based on the Time attribute of the asymmetry.

        Parameters
        ----------
        min_time : float
            Lower boundary of the time for the new asymmetry.
        max_time : float
            Upper boundary of the time for the new asymmetry.

        Returns
        -------
        asymmetry : Asymmetry
            A new asymmetry object cut between the specified times.

        Raises
        ------
        ValueError : Provided times create an invalid range. (Min time > Max time)
        """
        start_index = 0

        if min_time is not None:
            if max_time is not None and min_time >= max_time:
                raise ValueError(
                    "Min_time and max_time create an invalid range of asymmetry ({} -> {})".format(min_time, max_time))
            if min_time > self.time[-1]:
                return Asymmetry(input_array=[], time_zero=self.time_zero, bin_size=self.bin_size, time=[],
                                 uncertainty=[], alpha=self.alpha, calculated=None if self.calculated is None else [])
        else:
            min_time = self.time[0] - 1

        if max_time is None:
            max_time = self.time[-1] + 1

        for i, n in enumerate(self.time):
            if n >= min_time:
                start_index = i
                break

        for i, n in enumerate(self.time):
            if n >= max_time:
                end_index = i
                break
        else:
            end_index = len(self)

        return Asymmetry(input_array=self[start_index: end_index], time_zero=self.time_zero, bin_size=self.bin_size,
                         time=self.time[start_index: end_index], uncertainty=self.uncertainty[start_index: end_index],
                         alpha=self.alpha,
                         calculated=None if self.calculated is None else self.calculated[start_index: end_index])

    @staticmethod
    def fft(asymmetry, time, f_min, f_max):
        f_step = (f_max - f_min) / 200
        z_min = 2 * np.pi * f_min
        z_max = 2 * np.pi * f_max
        z_step = 2 * np.pi * f_step

        low_step = int(np.ceil((z_min - 1e-8) / z_step))
        high_step = int(np.floor((z_max + 1e-8) / z_step)) + 1
        z = np.arange(low_step, high_step) * z_step

        try:
            x_step = time[1] - time[0]
        except IndexError:
            return [0], [0]

        if (time[0] - 0.01 * x_step) > 0:
            nn = int(np.round(time[0] / x_step))
            add_me = np.linspace(0.0, time[0] - x_step, nn)
            time = np.concatenate((add_me, time))
            asymmetry = np.concatenate((0.0 * add_me, asymmetry))

        x_max_z_step = np.pi / z_step
        nin = len(time)
        n_base = max([nin, high_step, x_max_z_step / x_step])
        n_log_2 = int(np.ceil(np.log2(n_base)))
        n_out = 2 ** n_log_2
        x_max_db = 2 * n_out * x_step
        y_in_db = np.concatenate((asymmetry, np.zeros(2 * n_out - nin)))
        cy_out_db = np.fft.fft(y_in_db) * x_max_db
        fz_db = cy_out_db
        z_step_fine = 2 * np.pi / x_max_db
        z_fine = np.arange(n_out) * z_step_fine
        fz_fine = fz_db[:n_out]
        fzr = np.interp(z, z_fine, np.real(fz_fine))
        fzi = np.interp(z, z_fine, np.imag(fz_fine))

        if z[0] + 0.0001 * z_step < 0:
            nn = int(np.round(-z[0] / z_step))
            fzr[:nn] = 1.0 * fzr[2 * nn:nn:-1]
            fzi[:nn] = -1.0 * fzi[2 * nn:nn:-1]

        fz = fzr + 1j * fzi

        z = z / (2 * np.pi)
        fft = np.real(fz * np.conj(fz))

        return z, fft


class Uncertainty(np.ndarray, PersistentObject):
    """
        Represents the calculated uncertainty from taking the asymmetry of two histograms with the corresponding
        attributes. Inherits from numpy.ndarray so we can perform numpy calculations on it with casting it to an
        numpy array.
        """

    def get_persistent_data(self):
        return self._recursive_build(
            input_array=list(self),
            bin_size=self.bin_size
        )

    @staticmethod
    def build_from_persistent_data(data):
        return None if data is None else Uncertainty(**data)

    def __new__(cls, input_array=None, bin_size=None, histogram_one=None, histogram_two=None, **kwargs):
        if (input_array is None or bin_size is None) and (histogram_one is None or histogram_two is None):
            raise ValueError("Not enough constructor parameters satisfied")

        if input_array is None:
            start_bin_one, start_bin_two, end_bin_one, end_bin_two, time_zero = histogram_one.intersect(histogram_two)
            histogram_one_good = histogram_one[start_bin_one - 1: end_bin_one]
            histogram_two_good = histogram_two[start_bin_one - 1: end_bin_one]
            d_histogram_one = np.sqrt(histogram_one_good)
            d_histogram_two = np.sqrt(histogram_two_good)
            np.nan_to_num(histogram_one_good)
            np.nan_to_num(histogram_two_good)
            np.seterr(divide='ignore', invalid='ignore')
            input_array = np.array(np.sqrt(np.power(
                (2 * histogram_one_good * d_histogram_two / np.power(histogram_two_good + histogram_one_good, 2)), 2) +
                                           np.power((2 * histogram_two_good * d_histogram_one / np.power(
                                               histogram_two_good + histogram_one_good, 2)), 2)))
            np.seterr(divide='warn', invalid='warn')
            np.nan_to_num(input_array, copy=False)

            if histogram_one.bin_size != histogram_two.bin_size:
                raise ValueError("Histograms do not have the same bin size")
            bin_size = histogram_one.bin_size

        self = np.asarray(input_array).view(cls)
        self.bin_size = float(bin_size)

        return self

    def __eq__(self, other):
        return self.bin_size == other.bin_size and np.array_equal(self, other)

    def __repr__(self):
        return f'Uncertainty({repr(super)}, {self.bin_size})'

    def __reduce__(self):
        pickled_state = super(Uncertainty, self).__reduce__()

        new_state = pickled_state[2] + (self.__dict__,)

        return pickled_state[0], pickled_state[1], new_state

    def __setstate__(self, state, **kwargs):
        self.__dict__.update(state[-1])
        super(Uncertainty, self).__setstate__(state[0:-1])

    def __array_finalize__(self, obj):
        if obj is None:
            return

        self.bin_size = getattr(obj, 'bin_size', None)

    @classmethod
    def from_array(cls):
        pass

    @classmethod
    def from_histogram(cls):
        pass

    def bin(self, packing):
        bin_full = self.bin_size / 1000
        bin_binned = float(packing) / 1000
        num_bins = len(self)

        if bin_binned <= bin_full:
            return Uncertainty(self, self.bin_size)

        binned_indices_per_bin = int(np.round(bin_binned / bin_full))
        binned_indices_total = int(np.floor(num_bins / binned_indices_per_bin))
        leftover_bins = int(num_bins % binned_indices_per_bin)

        if leftover_bins:
            reshaped_uncertainty = np.reshape(self[:-leftover_bins],
                                              (binned_indices_total, binned_indices_per_bin))
        else:
            reshaped_uncertainty = np.reshape(self, (binned_indices_total, binned_indices_per_bin))

        try:
            binned_uncertainty = 1 / binned_indices_per_bin * np.sqrt(np.apply_along_axis(np.sum, 1,
                                                                                          reshaped_uncertainty ** 2))
        except ValueError:
            raise ValueError("Invalid bin size provided for binning uncertainty.")

        return Uncertainty(binned_uncertainty, packing)


class Time(np.ndarray, PersistentObject):
    """
        Represents the calculated uncertainty from taking the asymmetry of two histograms with the corresponding
        attributes. Inherits from numpy.ndarray so we can perform numpy calculations on it with casting it to an
        numpy array.
        """

    def get_persistent_data(self):
        return self._recursive_build(
            input_array=list(self),
            bin_size_ns=self.bin_size,
            length=self.length,
            time_zero_bin=self.time_zero,
            run_id=self.id
        )

    @staticmethod
    def build_from_persistent_data(data):
        return None if data is None else Time(**data)

    def __new__(cls, input_array=None, bin_size_ns=None, length=None, time_zero_bin=None, run_id=None,
                time_zero_ns=None,
                **kwargs):
        if (input_array is None) and (
                bin_size_ns is None or length is None or (time_zero_bin is None and time_zero_ns is None)):
            raise ValueError("Invalid combination of constructor parameters provided.")
        if input_array is None and time_zero_ns is not None:
            input_array = (np.arange(length) * float(bin_size_ns) / 1000) + time_zero_ns
        elif input_array is None:
            input_array = (np.arange(length) * float(bin_size_ns) / 1000) + \
                          (time_zero_bin * float(bin_size_ns) / 1000)

        self = np.asarray(input_array).view(cls)
        self.bin_size = float(bin_size_ns)
        self.length = len(input_array) if length is None else float(length)
        self.time_zero = 0 if time_zero_bin is None else float(time_zero_bin)
        self.id = run_id

        return self

    def __eq__(self, other):
        return self.bin_size == other.bin_size \
               and np.array_equal(self, other) \
               and self.time_zero == other.time_zero

    def __repr__(self):
        return f'Time({repr(super)}, {self.bin_size}, {self.time_zero}, {self.id})'

    def __reduce__(self):
        pickled_state = super(Time, self).__reduce__()

        new_state = pickled_state[2] + (self.__dict__,)

        return pickled_state[0], pickled_state[1], new_state

    def __setstate__(self, state, **kwargs):
        self.__dict__.update(state[-1])
        super(Time, self).__setstate__(state[0:-1])

    def __array_finalize__(self, obj):
        if obj is None:
            return

        self.length = getattr(obj, 'length', None)
        self.bin_size = getattr(obj, 'bin_size', None)
        self.time_zero = getattr(obj, 'time_zero', None)
        self.id = getattr(obj, 'id', None)

    def bin(self, packing):
        bin_full = float(self.bin_size) / 1000
        bin_binned = float(packing) / 1000
        num_bins = len(self)
        t0 = self.time_zero

        if bin_binned <= bin_full:
            return Time(self, bin_size_ns=self.bin_size, time_zero_bin=self.time_zero, run_id=self.id)

        binned_indices_per_bin = int(np.round(bin_binned / bin_full))
        binned_indices_total = int(np.floor(num_bins / binned_indices_per_bin))
        time_per_binned = binned_indices_per_bin * bin_full

        return Time((np.arange(binned_indices_total) * time_per_binned) + (t0 * bin_full) + (time_per_binned / 2),
                    bin_size_ns=packing, time_zero_bin=self.time_zero)


class Fit(PersistentObject):
    def get_persistent_data(self):
        return self._recursive_build(
            fit_id=self.id,
            parameters=self.parameters,
            expression=self.string_expression,
            title=self.title,
            run_id=self.run_id,
            meta=self.meta,
            asymmetry=self.asymmetry,
            goodness=self.goodness
        )

    @staticmethod
    def build_from_persistent_data(data):
        if data is None:
            return

        data["asymmetry"] = Asymmetry.build_from_persistent_data(data.pop("asymmetry"))
        return Fit(**data)

    def __init__(self, parameters, expression, title, run_id, meta, asymmetry: Asymmetry,
                 goodness: float = None, fit_id=None):
        self.id = str(uuid.uuid4()) if fit_id is None else fit_id
        self.parameters = parameters
        self.string_expression = expression
        self.title = title
        self.run_id = run_id  # "UNLINKED" -> run_id of the dataset you created
        self.meta = meta
        self.asymmetry = asymmetry  # Prompt with the plot prompt
        self.goodness = None if goodness is None else float(goodness)

        from app.model import fit
        self.expression = fit.FitExpression(expression)

    def __eq__(self, other):
        return self.parameters == other.parameters and self.string_expression == other.string_expression

    def __repr__(self):
        return f'Fit({self.id}, {self.parameters}, {self.string_expression}, {self.title} ,{self.run_id}, {self.meta}' \
               f', {self.asymmetry}, {self.goodness}, {repr(self.expression)})'

    def write(self, out_file, bin_size=None, x_min=None, x_max=None):
        meta_string = files.TITLE_KEY + ":" + str(self.title) + "," \
                      + files.BIN_SIZE_KEY + ":" + str(bin_size if bin_size else self.meta[files.BIN_SIZE_KEY]) + "," \
                      + files.TEMPERATURE_KEY + ":" + str(self.meta[files.TEMPERATURE_KEY]) + "," \
                      + files.FIELD_KEY + ":" + str(self.meta[files.FIELD_KEY]) + "," \
                      + files.T0_KEY + ":" + str(self.meta[files.T0_KEY])  # TODO not correct t0, need to fix that.

        runs = services.RunService().get_runs_by_ids([self.run_id])

        if len(runs) == 0:
            raise Exception("Run ID in fit '{}' did not match any in database.".format(self.title))

        run = runs[0]

        asymmetry = run.asymmetries[RunDataset.FULL_ASYMMETRY]
        for v in self.parameters.values():
            if v.symbol == "\u03B1":
                asymmetry = asymmetry.correct(v.value)

        if bin_size:
            asymmetry = asymmetry.bin(bin_size)

        if x_min or x_max:
            asymmetry = asymmetry.cut(x_min, x_max)

        if self.expression:
            calculated_asymmetry = self.expression(asymmetry.time,
                                                   **{v.symbol: v.value for v in self.parameters.values()})
        else:
            raise Exception("Expression has not been created for fit '{}'".format(self.title))

        np.savetxt(out_file, np.c_[asymmetry.time, asymmetry, calculated_asymmetry, asymmetry.uncertainty],
                   fmt='%2.9f, %2.4f, %2.4f, %2.4f',
                   header="BEAMS\n" + meta_string + "\nTime, Asymmetry, Calculated, Uncertainty")


class FitDataset(PersistentObject):
    class Flags:
        GLOBAL = 1
        GLOBAL_PLUS = 2
        BATCH = 3

    def get_persistent_data(self):
        return self._recursive_build(
            dataset_id=self.id,
            title=self.title,
            fits=self.fits,
            flags=self.flags,
            expression=self.expression,
            is_loaded=self.is_loaded
        )

    @staticmethod
    def build_from_persistent_data(data):
        data["fits"] = {k: Fit.build_from_persistent_data(v) for k, v in data.pop("fits").items()}
        return FitDataset(**data)

    def __init__(self, dataset_id=None, title=None, fits=None, flags=None, expression=None, is_loaded=None):
        t = time.localtime()
        current_time = time.strftime("%d-%m-%YT%H:%M:%S", t)

        self.id = dataset_id if dataset_id is not None else str(uuid.uuid4())
        self.title = title if title is not None else str(current_time)
        self.fits = fits if fits is not None else {}  # run_id : fit object
        self.flags = flags if flags is not None else 0
        self.expression = expression if expression is not None else None
        self.is_loaded = is_loaded if is_loaded is not None else False

    def __eq__(self, other):
        return isinstance(other, self.__class__) \
               and other.id == self.id

    def __repr__(self):
        return f'FitDataset({self.title}, {self.flags}, {self.expression}, {self.is_loaded}, {self.id}, {self.fits})'

    def __hash__(self):
        return hash(self.id)

    def equals(self, other):
        return self == other and self.title == other.title \
               and self.fits == other.fits and self.flags == other.flags \
               and self.expression == other.expression and self.is_loaded == other.is_loaded


    def write(self, out_file, order_by_key, parameter=None):
        if parameter:
            fit_parameters_string = self.__write_parameter(order_by_key, parameter)
        else:
            fit_parameters_string = self.__write_summary(order_by_key)

        # Write out our string
        with open(out_file, 'w', encoding="utf-8") as out_file_object:
            out_file_object.write("#BEAMS\n"
                                  + fit_parameters_string
                                  + "# Fitting equation\n\n\t"
                                  + "# A(t) = " + str(self.expression))

    def __write_summary(self, order_by_key):
        # Writing the Summary Block
        fit_parameters_string = "\n# Summary\n"

        f = list(self.fits.values())[0]

        fit_parameters_string += "{:<8}\t".format(files.RUN_NUMBER_KEY)
        if order_by_key != files.RUN_NUMBER_KEY:
            fit_parameters_string += "{:<12}\t".format(order_by_key)

        for name, v in f.parameters.items():  # getting the column headers
            fit_parameters_string += "{:<8}\t".format(name)
        fit_parameters_string += "\n"

        fit_list = self.__sort_fit_list(list(self.fits.values()), order_by_key)

        for f in fit_list:  # adding values for each run
            fit_parameters_string += "{:<8}\t".format(f.meta[files.RUN_NUMBER_KEY])
            if order_by_key != files.RUN_NUMBER_KEY:
                fit_parameters_string += "{:<12}\t".format(f.meta[order_by_key])
            for name, v in f.parameters.items():
                fit_parameters_string += "{:<8}\t".format("{:.5f}".format(v.value))
            # run = services.RunService().get_runs_by_ids([f.run_id])[0]
            fit_parameters_string += "\n"

        # Writing the Verbose Section
        fit_parameters_string += "\n# Fit Parameters\n\n# \t{:<8}{:<10}{:<12}{:<8}{:<8}".format("Name", "Value",
                                                                                                "Uncertainty", "Lower",
                                                                                                "Upper") + "\n\n"

        if self.flags & FitDataset.Flags.GLOBAL or self.flags & FitDataset.Flags.GLOBAL_PLUS:  # Add common parameters
            fit_parameters_string += "# Common parameters for all runs\n\n"

            f = list(self.fits.values())[0]
            for name, v in f.parameters.items():
                if v.is_global:
                    fit_parameters_string += "\t" + "{:<8}{:<10.5f}{:<12.5f}{:<8.5f}{:<8.5f}".format(v.symbol,
                                                                                                     v.value,
                                                                                                     v.uncertainty,
                                                                                                     v.lower,
                                                                                                     v.upper) + "\n"

            fit_parameters_string += "\n"

        for f in self.fits.values():  # Add run specific parameters
            run = services.RunService().get_runs_by_ids([f.run_id])[0]
            fit_parameters_string += run.file.file_path + "\n"
            fit_parameters_string += "# Specific parameters for run {} ({})\n\n".format(run.meta["RunNumber"],
                                                                                        f.title)

            for name, v in f.parameters.items():
                if not v.is_global:
                    fit_parameters_string += "\t" + "{:<8}{:<10.5f}{:<12.5f}{:<8.5f}{:<8.5f}".format(v.symbol,
                                                                                                     v.value,
                                                                                                     v.uncertainty,
                                                                                                     v.lower,
                                                                                                     v.upper) + "\n"

            fit_parameters_string += "\n"
        return fit_parameters_string

    def __write_parameter(self, ind_var, parameter):
        fit_parameters_string = "\n# Parameter Export\n\n"
        if ind_var == files.TEMPERATURE_KEY:
            fit_parameters_string += "# {:<12}(K)\t".format(ind_var)
            fit_parameters_string += "{:<12}\t".format("Uncertainty")
        elif ind_var == files.FIELD_KEY:
            fit_parameters_string += "# {:<12}\t".format(ind_var + ' (G)')
        else:
            fit_parameters_string += "# {:<12}\t".format(ind_var)
        fit_parameters_string += "{:<8}\t".format(parameter)
        fit_parameters_string += "{:<12}\t\n".format("Uncertainty")

        fit_list = self.__sort_fit_list(list(self.fits.values()), ind_var)
        for f in fit_list:
            if ind_var == files.TEMPERATURE_KEY:
                temp, uncertainty = re.findall("[-+]?[0-9]*\\.[0-9]+", f.meta[ind_var])
                fit_parameters_string += "{:<17}\t".format(temp)
                fit_parameters_string += "{:<12}\t".format(uncertainty)
            elif ind_var == files.FIELD_KEY:
                field = re.search("[-+]?[0-9]*\\.[0-9]+", f.meta[ind_var])[0]
                fit_parameters_string += "{:<12}\t".format(field)
            else:
                fit_parameters_string += "{:<14}\t".format(f.meta[ind_var])
            fit_parameters_string += "{:<8.5f}\t".format(f.parameters[parameter].fixed_value)
            fit_parameters_string += "{:<12.5f}\t\n".format(f.parameters[parameter].uncertainty)

        fit_parameters_string += "\n"
        return fit_parameters_string

    def __sort_fit_list(self, fit_list, order_by_key):
        try:
            fit_list.sort(
                key=lambda fit: float(re.search("[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?", fit.meta[order_by_key])[0]))
        except IndexError:
            pass

        return fit_list


class RunDataset(PersistentObject):
    FULL_ASYMMETRY = 1
    LEFT_BINNED_ASYMMETRY = 2
    RIGHT_BINNED_ASYMMETRY = 3

    def get_persistent_data(self):
        return self._recursive_build(
            id=self.id,
            histograms=self.histograms,
            asymmetries=self.asymmetries,
            meta=self.meta,
            file=self.file,
            histograms_used=self.histograms_used,
            is_loaded=self.is_loaded
        )

    @staticmethod
    def build_from_persistent_data(data):
        dataset = RunDataset()
        dataset.id = data["id"]
        dataset.histograms = {k: Histogram.build_from_persistent_data(v) for k, v in data["histograms"].items()}
        dataset.asymmetries = {k: Asymmetry.build_from_persistent_data(v) for k, v in data["asymmetries"].items()}
        dataset.meta = data["meta"]
        dataset.file = data["file"]
        dataset.histograms_used = data["histograms_used"]
        dataset.is_loaded = data["is_loaded"]
        return dataset

    def __init__(self):
        self.id = str(uuid.uuid4())

        self.histograms = {}

        self.asymmetries = {
            self.FULL_ASYMMETRY: None,
            self.LEFT_BINNED_ASYMMETRY: None,
            self.RIGHT_BINNED_ASYMMETRY: None
        }

        self.meta = None
        self.file = None
        self.histograms_used = []
        self.is_loaded = False

    def __eq__(self, other):
        return isinstance(other, self.__class__) \
               and other.id == self.id

    def __repr__(self):
        return f'RunDataset({self.id}, {self.file}, {self.meta}, {self.histograms}, {self.histograms_used}, ' \
               f'{self.asymmetries})'

    def __hash__(self):
        return hash(self.id)

    def equals(self, other):
        return self == other \
               and other.meta == self.meta \
               and other.histograms_used == self.histograms_used \
               and other.histograms == self.histograms \
               and other.asymmetries == self.asymmetries

    def write(self, out_file, format=None, bin_size=None):
        if format == files.Extensions.HISTOGRAM:
            meta_string = files.create_meta_string(self.meta)

            histograms = [hist for hist in self.histograms.values()]
            histograms = np.fliplr(np.rot90(histograms, 3))
            np.savetxt(out_file, histograms, delimiter=',', header=meta_string, comments="",
                       fmt="%-8i")
        elif self.asymmetries[self.FULL_ASYMMETRY] is not None:
            meta_string = files.TITLE_KEY + ":" + str(self.meta[files.TITLE_KEY]) + "," \
                          + files.BIN_SIZE_KEY + ":" + str(
                bin_size if bin_size else self.meta[files.BIN_SIZE_KEY]) + "," \
                          + files.RUN_NUMBER_KEY + ":" + str(self.meta[files.RUN_NUMBER_KEY]) + "," \
                          + files.TEMPERATURE_KEY + ":" + str(self.meta[files.TEMPERATURE_KEY]) + "," \
                          + files.FIELD_KEY + ":" + str(self.meta[files.FIELD_KEY]) + "," \
                          + files.T0_KEY + ":" + str(self.asymmetries[self.FULL_ASYMMETRY].time.time_zero)
            if bin_size:
                asymmetry = self.asymmetries[RunDataset.FULL_ASYMMETRY].bin(bin_size)
            else:
                asymmetry = self.asymmetries[RunDataset.FULL_ASYMMETRY]

            np.savetxt(out_file, np.c_[asymmetry.time, asymmetry, asymmetry.uncertainty],
                       fmt='%2.9f, %2.4f, %2.4f', header='BEAMS\n' + meta_string + "\nTime, Asymmetry, Uncertainty")


class FileDataset(PersistentObject):
    def get_persistent_data(self):
        return self._recursive_build(
            id=self.id,
            file_path=self.file_path,
            title=self.title,
            is_loaded=self.is_loaded,
            dataset=self.dataset.get_persistent_data()
        )

    @staticmethod
    def build_from_persistent_data(data):
        file = files.file(data["file_path"])
        file_dataset = FileDataset(file)
        file_dataset.title = data["title"]
        file_dataset.is_loaded = data["is_loaded"]
        file_dataset.id = data["id"]

        dataset = data["dataset"]
        file_dataset.dataset = None if dataset is None else RunDataset.build_from_persistent_data(dataset)

        return file_dataset

    def __init__(self, file):
        self.id = str(uuid.uuid4())

        self.file = file
        self.file_path = file.file_path
        self.title = os.path.split(file.file_path)[1]
        self.is_loaded = False
        self.dataset = None

    def __eq__(self, other):
        return isinstance(other, self.__class__) and other.id == self.id

    def __repr__(self):
        return f'FileDataset({self.title}, {self.file}, {self.file_path}, {self.id}, {self.is_loaded}, {self.dataset})'

    def __hash__(self):
        return hash(self.id)

    def equals(self, other):
        return self == other \
               and other.file_path == self.file_path \
               and str(other.title) == str(self.title) \
               and other.dataset.equals(self.dataset)


class DataBuilder:
    @staticmethod
    def build_minimal(f: files.ReadableFile):
        if not isinstance(f, File):
            f = files.file(f)

        if f.DATA_FORMAT == files.Format.HISTOGRAM or \
                f.DATA_FORMAT == files.Format.ASYMMETRY or \
                f.DATA_FORMAT == files.Format.FIT:
            run = RunDataset()
            run.meta = f.read_meta()
            run.file = f
            return run

        elif f.DATA_FORMAT == files.Format.FIT_SET_VERBOSE:
            from app.model import fit

            common, specific, expression = f.read_data()
            fit_dataset = FitDataset()
            fit_dataset.expression = expression
            for run_number, (title, file_path, specific_parameters) in specific.items():
                parameters = {symbol: fit.FitParameter(symbol, float(value), float(lower), float(upper), False, False,
                                                       output=float(value), uncertainty=float(uncertainty)) for
                              symbol, value, uncertainty, lower, upper in specific_parameters}
                parameters.update(
                    {symbol: fit.FitParameter(symbol, float(value), float(lower), float(upper), False, False,
                                              output=float(value), uncertainty=float(uncertainty)) for
                     symbol, value, uncertainty, lower, upper in common})

                unlinked_run_id = 'UNLINKED' + str(uuid.uuid4())
                fi = Fit(parameters, expression, title, unlinked_run_id,
                         {files.RUN_NUMBER_KEY: run_number,
                          files.TITLE_KEY: title,
                          files.FILE_PATH_KEY: file_path}, None)
                fit_dataset.fits[unlinked_run_id] = fi
            return fit_dataset

        elif f.DATA_FORMAT == files.Format.FIT_SET:
            data = f.read_data().to_dict()
            run_numbers = data.pop('RUN')
            run_parameters = {}
            for i, _ in enumerate(run_numbers):
                run_parameters[run_numbers[i]] = {symbol: values[i] for symbol, values in data.items()}
            return run_parameters
        else:
            return None

    @staticmethod
    def build_full(f, d=None):
        if not isinstance(f, File):
            f = files.file(f)

        if d is None or (not isinstance(d, RunDataset) and not isinstance(d, FitDataset)):
            if f.DATA_FORMAT == files.Format.HISTOGRAM or \
                    f.DATA_FORMAT == files.Format.ASYMMETRY:
                d = RunDataset()
                d.meta = f.read_meta()
                d.file = f

        if f.DATA_FORMAT == files.Format.HISTOGRAM:
            data = f.read_data()
            for histogram_title in d.meta[files.HIST_TITLES_KEY]:
                histogram = Histogram(time_zero=d.meta[files.T0_KEY][histogram_title],
                                      good_bin_start=d.meta[files.GOOD_BIN_ONE_KEY][histogram_title],
                                      good_bin_end=d.meta[files.GOOD_BIN_TWO_KEY][histogram_title],
                                      background_start=d.meta[files.BACKGROUND_ONE_KEY][histogram_title],
                                      background_end=d.meta[files.BACKGROUND_TWO_KEY][histogram_title],
                                      title=histogram_title,
                                      run_id=d.id,
                                      bin_size=d.meta[files.BIN_SIZE_KEY],
                                      input_array=data[histogram_title])
                d.histograms[histogram_title] = histogram
            d.is_loaded = True

        elif f.DATA_FORMAT == files.Format.ASYMMETRY:
            data = f.read_data()

            uncertainty = Uncertainty(data["Uncertainty"], bin_size=d.meta[files.BIN_SIZE_KEY])
            times = Time(data["Time"], time_zero_bin=d.meta[files.T0_KEY], bin_size_ns=d.meta[files.BIN_SIZE_KEY])

            asymmetry = Asymmetry(input_array=data["Asymmetry"],
                                  time_zero=d.meta[files.T0_KEY],
                                  bin_size=d.meta[files.BIN_SIZE_KEY],
                                  uncertainty=uncertainty,
                                  time=times)

            d.asymmetries[d.FULL_ASYMMETRY] = asymmetry
            d.histograms = None
            d.is_loaded = True

        elif f.DATA_FORMAT == files.Format.FIT:
            data = f.read_data()

            uncertainty = Uncertainty(data["Uncertainty"], bin_size=d.meta[files.BIN_SIZE_KEY])
            times = Time(data["Time"], time_zero_bin=d.meta[files.T0_KEY], bin_size_ns=d.meta[files.BIN_SIZE_KEY])

            asymmetry = Asymmetry(input_array=data["Asymmetry"],
                                  time_zero=d.meta[files.T0_KEY],
                                  bin_size=d.meta[files.BIN_SIZE_KEY],
                                  uncertainty=uncertainty,
                                  time=times,
                                  calculated=data["Calculated"])

            d.asymmetries[d.FULL_ASYMMETRY] = asymmetry
            d.histograms = None
            d.is_loaded = True

        return d
