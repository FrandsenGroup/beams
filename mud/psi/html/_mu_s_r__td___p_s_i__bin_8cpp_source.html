<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Class MuSR_td_PSI_bin: MuSR_td_PSI_bin.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>MuSR_td_PSI_bin.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/********************************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  MuSR_td_PSI_bin.cpp</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  implementation of the class &apos;MuSR_td_PSI_bin&apos;</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  Main class to read mdu and td_bin PSI MuSR data.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">*********************************************************************************************</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">    begin                : Alex Amato, October 2005</span>
<a name="l00012"></a>00012 <span class="comment">    modified             : Andrea Raselli, October 2009</span>
<a name="l00013"></a>00013 <span class="comment">    copyright            : (C) 2005 by</span>
<a name="l00014"></a>00014 <span class="comment">    email                : alex.amato@psi.ch</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">********************************************************************************************/</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">/***************************************************************************</span>
<a name="l00019"></a>00019 <span class="comment"> *                                                                         *</span>
<a name="l00020"></a>00020 <span class="comment"> *   This program is free software; you can redistribute it and/or modify  *</span>
<a name="l00021"></a>00021 <span class="comment"> *   it under the terms of the GNU General Public License as published by  *</span>
<a name="l00022"></a>00022 <span class="comment"> *   the Free Software Foundation; either version 2 of the License, or     *</span>
<a name="l00023"></a>00023 <span class="comment"> *   (at your option) any later version.                                   *</span>
<a name="l00024"></a>00024 <span class="comment"> *                                                                         *</span>
<a name="l00025"></a>00025 <span class="comment"> ***************************************************************************/</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00029"></a>00029 <span class="keyword">using namespace </span>std ;
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;MuSR_td_PSI_bin.h&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">//*******************************</span>
<a name="l00038"></a>00038 <span class="comment">//Implementation constructor</span>
<a name="l00039"></a>00039 <span class="comment">//*******************************</span>
<a name="l00040"></a>00040 
<a name="l00044"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afb1d5e2cc825f52b60e07644ea5853f5">00044</a>  <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afb1d5e2cc825f52b60e07644ea5853f5" title="Simple Constructor setting some pointers and variables.">MuSR_td_PSI_bin::MuSR_td_PSI_bin</a>()
<a name="l00045"></a>00045   {
<a name="l00046"></a>00046     histo = NULL;
<a name="l00047"></a>00047     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00048"></a>00048   }
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">//*******************************</span>
<a name="l00052"></a>00052 <span class="comment">//Implementation destructor</span>
<a name="l00053"></a>00053 <span class="comment">//*******************************</span>
<a name="l00054"></a>00054 
<a name="l00058"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a35b22a273c26dbf4473a36bf4da533cf">00058</a>  <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a35b22a273c26dbf4473a36bf4da533cf" title="Simple Destructor clearing some pointers and variables.">MuSR_td_PSI_bin::~MuSR_td_PSI_bin</a>()
<a name="l00059"></a>00059   {
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">//*******************************</span>
<a name="l00067"></a>00067 <span class="comment">//Implementation read (generic read)</span>
<a name="l00068"></a>00068 <span class="comment">//*******************************</span>
<a name="l00069"></a>00069 
<a name="l00085"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a67c9ecf19ef04ea61e4d8b8306b0a0cc">00085</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a67c9ecf19ef04ea61e4d8b8306b0a0cc" title="Method to read a PSI-bin or an MDU file.">MuSR_td_PSI_bin::read</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * fileName)
<a name="l00086"></a>00086   {
<a name="l00087"></a>00087     ifstream  file_name ;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     filename    = fileName;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     file_name.open(fileName, ios_base::binary);  <span class="comment">// open file</span>
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00095"></a>00095     {
<a name="l00096"></a>00096       readstatus  = <span class="stringliteral">&quot;ERROR Open &quot;</span>+filename+<span class="stringliteral">&quot; failed!&quot;</span>;
<a name="l00097"></a>00097       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="keywordtype">char</span> *buffer_file = <span class="keyword">new</span> <span class="keywordtype">char</span>[3] ;
<a name="l00101"></a>00101     <span class="keywordflow">if</span> (!buffer_file)
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       readstatus = <span class="stringliteral">&quot;ERROR Allocating data buffer&quot;</span>;
<a name="l00104"></a>00104       <span class="keywordflow">return</span> 3;                 <span class="comment">// ERROR allocating data buffer</span>
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     file_name.read(buffer_file, 2) ;             <span class="comment">// read format identifier of header</span>
<a name="l00108"></a>00108                                                  <span class="comment">// into buffer</span>
<a name="l00109"></a>00109     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00110"></a>00110     {
<a name="l00111"></a>00111       file_name.close();
<a name="l00112"></a>00112       <span class="keyword">delete</span> [] buffer_file;
<a name="l00113"></a>00113       readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; header failed!&quot;</span>;
<a name="l00114"></a>00114       <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     strncpy(format_id,buffer_file,2);
<a name="l00118"></a>00118     format_id[2] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     file_name.close();
<a name="l00121"></a>00121     <span class="keyword">delete</span> [] buffer_file;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">// file may either be PSI binary format</span>
<a name="l00124"></a>00124     <span class="keywordflow">if</span> (strncmp(format_id,<span class="stringliteral">&quot;1N&quot;</span>,2) == 0)
<a name="l00125"></a>00125     {
<a name="l00126"></a>00126        <span class="keywordflow">return</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aba3ff7671a27790ab98b3e62a65c24ff" title="Method to read a PSI-bin file.">readbin</a>(fileName);  <span class="comment">// then read it as PSI bin</span>
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="comment">// or MDU format (pTA, TDC or 32 channel TDC)</span>
<a name="l00130"></a>00130     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((strncmp(format_id,<span class="stringliteral">&quot;M3&quot;</span>,2) == 0) ||(strncmp(format_id,<span class="stringliteral">&quot;T4&quot;</span>,2) == 0) ||
<a name="l00131"></a>00131              (strncmp(format_id,<span class="stringliteral">&quot;T5&quot;</span>,2) == 0))
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133        <span class="keywordflow">return</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a1db93f6e3dcf6202d29c1a133429ee29" title="Method to read a MuSR MDU file.">readmdu</a>(fileName); <span class="comment">// else read it as MDU</span>
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     <span class="keywordflow">else</span>
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137       readstatus  = <span class="stringliteral">&quot;ERROR Unknown file format in &quot;</span>+filename+<span class="stringliteral">&quot;!&quot;</span>;
<a name="l00138"></a>00138       <span class="keywordflow">return</span> 2 ;                                 <span class="comment">// ERROR unsupported version</span>
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">//*******************************</span>
<a name="l00144"></a>00144 <span class="comment">//Implementation readbin</span>
<a name="l00145"></a>00145 <span class="comment">//*******************************</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/* -- type definitions taken from tydefs.h -- */</span>
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="preprocessor">#if ((defined(__DECC) || defined(__VAXC)) &amp;&amp; !defined(unix) &amp;&amp; !defined(OS_OSF1))</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151 <span class="preprocessor">#if defined (__ALPHA)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="keyword">typedef</span>           <span class="keywordtype">short</span> <span class="keywordtype">int</span>      Int16;
<a name="l00153"></a>00153 <span class="keyword">typedef</span>                 <span class="keywordtype">int</span>      Int32;
<a name="l00154"></a>00154 <span class="preprocessor">#else</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="keyword">typedef</span>                 <span class="keywordtype">int</span>      Int16;
<a name="l00156"></a>00156 <span class="keyword">typedef</span>            <span class="keywordtype">long</span> <span class="keywordtype">int</span>      Int32;
<a name="l00157"></a>00157 <span class="preprocessor">#endif</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="preprocessor">#elif defined (__osf__)            </span><span class="comment">/* --- DEC UNIX or OFS/1 (AXP or else) --- */</span>
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="preprocessor">#if defined (__alpha)</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="keyword">typedef</span>           <span class="keywordtype">short</span> <span class="keywordtype">int</span>      Int16;
<a name="l00164"></a>00164 <span class="keyword">typedef</span>                 <span class="keywordtype">int</span>      Int32;
<a name="l00165"></a>00165 <span class="preprocessor">#else</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="keyword">typedef</span>                 <span class="keywordtype">int</span>      Int16;
<a name="l00167"></a>00167 <span class="keyword">typedef</span>            <span class="keywordtype">long</span> <span class="keywordtype">int</span>      Int32;
<a name="l00168"></a>00168 <span class="preprocessor">#endif</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00170"></a>00170 <span class="preprocessor">#else </span><span class="comment">/* other operating system */</span>
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">/* 32 bit word length */</span>
<a name="l00173"></a>00173 <span class="preprocessor">#if (defined(_WIN32) || defined(__linux__) || defined(_WIN32GCC))</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="keyword">typedef</span>                 <span class="keywordtype">short</span>    Int16;
<a name="l00175"></a>00175 <span class="keyword">typedef</span>                 <span class="keywordtype">int</span>      Int32;
<a name="l00176"></a>00176 <span class="preprocessor">#else</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="keyword">typedef</span>                 <span class="keywordtype">int</span>      Int16;
<a name="l00178"></a>00178 <span class="keyword">typedef</span>            <span class="keywordtype">long</span> <span class="keywordtype">int</span>      Int32;
<a name="l00179"></a>00179 <span class="preprocessor">#endif</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>
<a name="l00181"></a>00181 <span class="preprocessor">#endif</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>
<a name="l00183"></a>00183 <span class="keyword">typedef</span>                 <span class="keywordtype">float</span>   Float32;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="comment">/* ----------------------------------------- */</span>
<a name="l00186"></a>00186 
<a name="l00202"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aba3ff7671a27790ab98b3e62a65c24ff">00202</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aba3ff7671a27790ab98b3e62a65c24ff" title="Method to read a PSI-bin file.">MuSR_td_PSI_bin::readbin</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * fileName)
<a name="l00203"></a>00203   {
<a name="l00204"></a>00204     ifstream  file_name ;
<a name="l00205"></a>00205     Int16     *dum_Int16 ;
<a name="l00206"></a>00206     Int32     *dum_Int32 ;
<a name="l00207"></a>00207     Float32   *dum_Float32 ;
<a name="l00208"></a>00208     <span class="keywordtype">int</span>       i ;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     Int16    tdc_resolution ;
<a name="l00211"></a>00211     Int16    tdc_overflow  ;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     Float32  mon_low[4] ;
<a name="l00214"></a>00214     Float32  mon_high[4] ;
<a name="l00215"></a>00215     Int32    mon_num_events ;
<a name="l00216"></a>00216     <span class="keywordtype">char</span>     mon_dev[13] ;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     Int16    num_data_records_file ;
<a name="l00219"></a>00219     Int16    length_data_records_bins ;
<a name="l00220"></a>00220     Int16    num_data_records_histo ;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     Int32    period_save ;
<a name="l00223"></a>00223     Int32    period_mon ;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(Int16) != 2)
<a name="l00228"></a>00228     {
<a name="l00229"></a>00229       readstatus  = <span class="stringliteral">&quot;ERROR Size of Int16 data type is not 2 bytes!&quot;</span>;
<a name="l00230"></a>00230       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(Int32) != 4)
<a name="l00234"></a>00234     {
<a name="l00235"></a>00235       readstatus  = <span class="stringliteral">&quot;ERROR Sizeof Int32 data type is not 4 bytes&quot;</span>;
<a name="l00236"></a>00236       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(Float32) != 4)
<a name="l00240"></a>00240     {
<a name="l00241"></a>00241       readstatus  = <span class="stringliteral">&quot;ERROR Sizeof Float32 data type is not 4 bytes&quot;</span>;
<a name="l00242"></a>00242       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     filename    = fileName;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     file_name.open(fileName, ios_base::binary);  <span class="comment">// open PSI bin file</span>
<a name="l00248"></a>00248     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00249"></a>00249     {
<a name="l00250"></a>00250       readstatus  = <span class="stringliteral">&quot;ERROR Open &quot;</span>+filename+<span class="stringliteral">&quot; failed!&quot;</span>;
<a name="l00251"></a>00251       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     <span class="keywordtype">char</span> *buffer_file = <span class="keyword">new</span> <span class="keywordtype">char</span>[1024] ;
<a name="l00255"></a>00255     <span class="keywordflow">if</span> (!buffer_file)
<a name="l00256"></a>00256     {
<a name="l00257"></a>00257       readstatus = <span class="stringliteral">&quot;ERROR Allocating buffer to read header failed!&quot;</span>;
<a name="l00258"></a>00258       <span class="keywordflow">return</span> 3;                 <span class="comment">// ERROR allocating data buffer</span>
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     file_name.read(buffer_file, 1024) ;          <span class="comment">// read header into buffer</span>
<a name="l00262"></a>00262     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264       file_name.close();
<a name="l00265"></a>00265       <span class="keyword">delete</span> [] buffer_file;
<a name="l00266"></a>00266       readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; header failed!&quot;</span>;
<a name="l00267"></a>00267       <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269                                               <span class="comment">// fill header data into member variables</span>
<a name="l00270"></a>00270     strncpy(format_id,buffer_file,2);
<a name="l00271"></a>00271     format_id[2] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (strcmp(format_id,<span class="stringliteral">&quot;1N&quot;</span>) != 0)
<a name="l00274"></a>00274     {
<a name="l00275"></a>00275       file_name.close();
<a name="l00276"></a>00276       <span class="keyword">delete</span> [] buffer_file;
<a name="l00277"></a>00277       readstatus  = <span class="stringliteral">&quot;ERROR Unknown file format in &quot;</span>+filename+<span class="stringliteral">&quot;!&quot;</span>;
<a name="l00278"></a>00278       <span class="keywordflow">return</span> 2 ;                                 <span class="comment">// ERROR unsupported version</span>
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281                       dum_Int16 = (Int16 *) &amp;buffer_file[2] ;
<a name="l00282"></a>00282     tdc_resolution = *dum_Int16 ;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284                       dum_Int16 = (Int16 *) &amp;buffer_file[4] ;
<a name="l00285"></a>00285     tdc_overflow   = *dum_Int16 ;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287                       dum_Int16 = (Int16 *) &amp;buffer_file[6] ;
<a name="l00288"></a>00288     num_run        = *dum_Int16 ;
<a name="l00289"></a>00289 
<a name="l00290"></a>00290                       dum_Int16 = (Int16 *) &amp;buffer_file[28] ;
<a name="l00291"></a>00291     length_histo   = *dum_Int16 ;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293                       dum_Int16 = (Int16 *) &amp;buffer_file[30] ;
<a name="l00294"></a>00294     number_histo   = *dum_Int16 ;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     strncpy(sample,buffer_file+138,10) ;
<a name="l00297"></a>00297             sample[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     strncpy(temp,buffer_file+148,10) ;
<a name="l00300"></a>00300             temp[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     strncpy(field,buffer_file+158,10) ;
<a name="l00303"></a>00303             field[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     strncpy(orient,buffer_file+168,10) ;
<a name="l00306"></a>00306             orient[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     strncpy(comment,buffer_file+860,62) ;
<a name="l00309"></a>00309             comment[62] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     strncpy(date_start,buffer_file+218,9) ;
<a name="l00312"></a>00312             date_start[9] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     strncpy(date_stop,buffer_file+227,9) ;
<a name="l00315"></a>00315             date_stop[9] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317     strncpy(time_start,buffer_file+236,8) ;
<a name="l00318"></a>00318             time_start[8] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     strncpy(time_stop,buffer_file+244,8) ;
<a name="l00321"></a>00321             time_stop[8] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323                       dum_Int32 = (Int32 *) &amp;buffer_file[424] ;
<a name="l00324"></a>00324     total_events   = *dum_Int32 ;
<a name="l00325"></a>00325 
<a name="l00326"></a>00326     <span class="keywordflow">for</span> (i=0; i&lt;=15; i++)
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328       strncpy(labels_histo[i],buffer_file+948+i*4,4) ;
<a name="l00329"></a>00329               labels_histo[i][4] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331                              dum_Int32 = (Int32 *) &amp;buffer_file[296+i*4] ;
<a name="l00332"></a>00332       events_per_histo[i] = *dum_Int32 ;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334                              dum_Int16 = (Int16 *) &amp;buffer_file[458+i*2] ;
<a name="l00335"></a>00335       integer_t0[i]       = *dum_Int16 ;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337                              dum_Int16 = (Int16 *) &amp;buffer_file[490+i*2] ;
<a name="l00338"></a>00338       first_good[i]       = *dum_Int16 ;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340                              dum_Int16 = (Int16 *) &amp;buffer_file[522+i*2] ;
<a name="l00341"></a>00341       last_good[i]        = *dum_Int16 ;
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     <span class="keywordflow">for</span> (i=0; i&lt;=15; i++)
<a name="l00345"></a>00345     {
<a name="l00346"></a>00346                              dum_Float32 = (Float32 *) &amp;buffer_file[792+i*4] ;
<a name="l00347"></a>00347       real_t0[i]          = *dum_Float32 ;
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     number_scaler = 18;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     <span class="keywordflow">for</span> (i=0; i&lt;=5; i++)
<a name="l00353"></a>00353     {
<a name="l00354"></a>00354                              dum_Int32 = (Int32 *) &amp;buffer_file[670+i*4] ;
<a name="l00355"></a>00355       scalers[i]          = *dum_Int32 ;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357       strncpy(labels_scalers[i],buffer_file+924+i*4,4) ;
<a name="l00358"></a>00358               labels_scalers[i][4] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <span class="keywordflow">for</span> (i=6; i&lt;number_scaler; i++)
<a name="l00362"></a>00362     {
<a name="l00363"></a>00363                              dum_Int32 = (Int32 *) &amp;buffer_file[360+(i-6)*4] ;
<a name="l00364"></a>00364       scalers[i]          = *dum_Int32 ;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366       strncpy(labels_scalers[i],buffer_file+554+(i-6)*4,4) ;
<a name="l00367"></a>00367               labels_scalers[i][4] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00368"></a>00368     }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370                              dum_Float32 = (Float32 *) &amp;buffer_file[1012] ;
<a name="l00371"></a>00371     bin_width             = *dum_Float32 ;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     <span class="keywordflow">if</span> (bin_width == 0.)
<a name="l00374"></a>00374     {
<a name="l00375"></a>00375       bin_width=(625.E-6)/8.*pow(Float32(2.),Float32(tdc_resolution)) ;
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     default_binning = 1;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     number_temper = 4;
<a name="l00381"></a>00381     <span class="keywordflow">for</span> (i=0; i&lt; number_temper; i++)
<a name="l00382"></a>00382     {
<a name="l00383"></a>00383                              dum_Float32 = (Float32 *) &amp;buffer_file[716+i*4] ;
<a name="l00384"></a>00384       temper[i]           = *dum_Float32 ;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386                              dum_Float32 = (Float32 *) &amp;buffer_file[738+i*4] ;
<a name="l00387"></a>00387       temp_deviation[i]   = *dum_Float32 ;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389                              dum_Float32 = (Float32 *) &amp;buffer_file[72+i*4] ;
<a name="l00390"></a>00390       mon_low[i]          = *dum_Float32 ;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392                              dum_Float32 = (Float32 *) &amp;buffer_file[88+i*4] ;
<a name="l00393"></a>00393       mon_high[i]         = *dum_Float32 ;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396                              dum_Int32 = (Int32 *) &amp;buffer_file[712] ;
<a name="l00397"></a>00397     mon_num_events        = *dum_Int32 ;
<a name="l00398"></a>00398     strncpy(mon_dev,buffer_file+60,12) ;
<a name="l00399"></a>00399             mon_dev[12] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401                                 dum_Int16 = (Int16 *) &amp;buffer_file[128] ; <span class="comment">// numdaf</span>
<a name="l00402"></a>00402     num_data_records_file    = *dum_Int16 ;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                                 dum_Int16 = (Int16 *) &amp;buffer_file[130] ; <span class="comment">// lendaf</span>
<a name="l00405"></a>00405     length_data_records_bins = *dum_Int16 ;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407                                 dum_Int16 = (Int16 *) &amp;buffer_file[132] ; <span class="comment">// kdafhi</span>
<a name="l00408"></a>00408     num_data_records_histo   = *dum_Int16 ;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410                                 dum_Int16 = (Int16 *) &amp;buffer_file[134] ; <span class="comment">// khidaf</span>
<a name="l00411"></a>00411     <span class="keywordflow">if</span> (*dum_Int16 != 1)
<a name="l00412"></a>00412     {
<a name="l00413"></a>00413       cout &lt;&lt; <span class="stringliteral">&quot;ERROR number of histograms/record not equals 1!&quot;</span>
<a name="l00414"></a>00414            &lt;&lt; <span class="stringliteral">&quot; Required algorithm is not implemented!&quot;</span> &lt;&lt; endl;
<a name="l00415"></a>00415       <span class="keyword">delete</span> [] buffer_file ;
<a name="l00416"></a>00416       file_name.close();
<a name="l00417"></a>00417       readstatus  = <span class="stringliteral">&quot;ERROR Algorithm to read multiple histograms in one block -&quot;</span>
<a name="l00418"></a>00418                     <span class="stringliteral">&quot; necessary to read &quot;</span> + filename + <span class="stringliteral">&quot; - is not implemented!&quot;</span>;
<a name="l00419"></a>00419       <span class="keywordflow">return</span> 4;                                <span class="comment">// ERROR algorithm not implemented</span>
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422                                 dum_Int32 = (Int32 *) &amp;buffer_file[654] ;
<a name="l00423"></a>00423     period_save              = *dum_Int32 ;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425                                 dum_Int32 = (Int32 *) &amp;buffer_file[658] ;
<a name="l00426"></a>00426     period_mon               = *dum_Int32 ;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keywordflow">if</span> (buffer_file) <span class="keyword">delete</span> [] buffer_file ;
<a name="l00429"></a>00429 
<a name="l00430"></a>00430     <span class="keywordflow">if</span> (number_histo &lt;= 0)
<a name="l00431"></a>00431     {
<a name="l00432"></a>00432       file_name.close();
<a name="l00433"></a>00433       readstatus  = <span class="stringliteral">&quot;ERROR Less than 1 histogram in &quot;</span>  + filename ;
<a name="l00434"></a>00434       <span class="keywordflow">return</span> 5;                                <span class="comment">// ERROR number of histograms &lt; 1</span>
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437     <span class="comment">// allocate histograms</span>
<a name="l00438"></a>00438     histo = <span class="keyword">new</span> <span class="keywordtype">int</span>* [int(number_histo)];
<a name="l00439"></a>00439     <span class="keywordflow">if</span> (!histo)
<a name="l00440"></a>00440     {
<a name="l00441"></a>00441       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00442"></a>00442       file_name.close();
<a name="l00443"></a>00443       readstatus = <span class="stringliteral">&quot;ERROR Allocating histo[] failed!&quot;</span>;
<a name="l00444"></a>00444       <span class="keywordflow">return</span> 3;                                <span class="comment">// ERROR allocating histogram buffer</span>
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     <span class="keywordflow">for</span> (i=0; i&lt;number_histo; i++)
<a name="l00448"></a>00448     {
<a name="l00449"></a>00449       histo[i] = <span class="keyword">new</span> <span class="keywordtype">int</span> [length_histo];
<a name="l00450"></a>00450 
<a name="l00451"></a>00451       <span class="keywordflow">if</span> (!histo[i])
<a name="l00452"></a>00452       {
<a name="l00453"></a>00453         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;i; j++)
<a name="l00454"></a>00454           <span class="keyword">delete</span> histo[j];
<a name="l00455"></a>00455         <span class="keyword">delete</span> [] histo;
<a name="l00456"></a>00456         histo = NULL;
<a name="l00457"></a>00457         <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00458"></a>00458         file_name.close();
<a name="l00459"></a>00459         readstatus = <span class="stringliteral">&quot;ERROR Allocating histo[] failed!&quot;</span>;
<a name="l00460"></a>00460         <span class="keywordflow">return</span> 3;                                <span class="comment">// ERROR allocating histogram buffer</span>
<a name="l00461"></a>00461       }
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="keywordtype">char</span> *buffer_file_histo = <span class="keyword">new</span> <span class="keywordtype">char</span>[Int32(num_data_records_file)
<a name="l00465"></a>00465                                       *Int32(length_data_records_bins)*4];
<a name="l00466"></a>00466     <span class="keywordflow">if</span> (!buffer_file_histo)
<a name="l00467"></a>00467     {
<a name="l00468"></a>00468       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00469"></a>00469       file_name.close();
<a name="l00470"></a>00470       readstatus = <span class="stringliteral">&quot;ERROR Allocating buffer to read histogram failed!&quot;</span>;
<a name="l00471"></a>00471       <span class="keywordflow">return</span> 3;                                <span class="comment">// ERROR allocating histogram buffer</span>
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473     file_name.seekg(1024, ios_base::beg) ;     <span class="comment">// beginning of histogram data</span>
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     file_name.read(buffer_file_histo, Int32(num_data_records_file)
<a name="l00476"></a>00476                                      *Int32(length_data_records_bins)*4) ;
<a name="l00477"></a>00477     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00478"></a>00478     {
<a name="l00479"></a>00479       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00480"></a>00480       <span class="keyword">delete</span> [] buffer_file_histo;
<a name="l00481"></a>00481       file_name.close();
<a name="l00482"></a>00482       readstatus  = <span class="stringliteral">&quot;ERROR Reading data in &quot;</span>+filename+<span class="stringliteral">&quot; failed!&quot;</span>;
<a name="l00483"></a>00483       <span class="keywordflow">return</span> 6;                                <span class="comment">// ERROR reading data failed</span>
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485     file_name.close();
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <span class="comment">// process histograms</span>
<a name="l00488"></a>00488     vector&lt;double&gt; dummy_vector ;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>.clear();
<a name="l00491"></a>00491     <span class="keywordflow">for</span> (i=0; i&lt;number_histo; i++)
<a name="l00492"></a>00492     {
<a name="l00493"></a>00493       dummy_vector.clear() ;
<a name="l00494"></a>00494       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;length_histo; j++)
<a name="l00495"></a>00495       {
<a name="l00496"></a>00496         dum_Int32 = (Int32 *) &amp;buffer_file_histo[(i*Int32(num_data_records_histo)*
<a name="l00497"></a>00497                                      Int32(length_data_records_bins)+j)*<span class="keyword">sizeof</span>(Int32)];
<a name="l00498"></a>00498         histo[i][j]= *dum_Int32 ;
<a name="l00499"></a>00499         dummy_vector.push_back(<span class="keywordtype">double</span>(histo[i][j])) ;
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>.push_back(dummy_vector) ;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504     <span class="keywordflow">if</span> (buffer_file_histo) <span class="keyword">delete</span> [] buffer_file_histo;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     readstatus = <span class="stringliteral">&quot;SUCCESS&quot;</span>;
<a name="l00507"></a>00507     readingok = <span class="keyword">true</span>;
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <span class="keywordflow">return</span> 0;
<a name="l00510"></a>00510   }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="comment">//*******************************</span>
<a name="l00513"></a>00513 <span class="comment">//Implementation readmdu</span>
<a name="l00514"></a>00514 <span class="comment">//*******************************</span>
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 <span class="preprocessor">#define DATESTR    12     </span><span class="comment">/* Length of date string 01-NOV-1999 */</span>
<a name="l00517"></a>00517 <span class="preprocessor">#define TIMESTR     9     </span><span class="comment">/* Length of time string 08:45:30 */</span>
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="comment">/* automatic data conversion */</span>
<a name="l00520"></a>00520 <span class="preprocessor">#define TITLESTR      40</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span><span class="preprocessor">#define SUBTITLESTR   62</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span><span class="preprocessor">#define DATAFORMATSTR 20</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="preprocessor">#define DETECTLISTSTR 200</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span><span class="preprocessor">#define TEMPLISTSTR   50</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span>
<a name="l00526"></a>00526   <span class="comment">/* - event types and event evaluation mode                                             */</span>
<a name="l00527"></a>00527 <span class="preprocessor">#define PTAMODE_NONE   0  </span><span class="comment">/* not initialised                                */</span>
<a name="l00528"></a>00528 <span class="preprocessor">#define PTAMODE_NORMAL 1  </span><span class="comment">/* &quot;normal&quot; events M-P..                          */</span>
<a name="l00529"></a>00529 <span class="preprocessor">#define PTAMODE_CLOCK  2  </span><span class="comment">/* additional clock generated events to prevent</span>
<a name="l00530"></a>00530 <span class="comment">                             overflow of pTA*/</span>
<a name="l00531"></a>00531 <span class="preprocessor">#define PTAMODE_ECHO   4  </span><span class="comment">/* echo mode M-P .. Echo (delayed M signal)       */</span>
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="comment">/* - tag types */</span>
<a name="l00534"></a>00534 <span class="preprocessor">#define PTATAGC_NONE       &apos;N&apos;</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span><span class="preprocessor">#define PTATAGC_MUON       &apos;M&apos;</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span><span class="preprocessor">#define PTATAGC_POSITRON   &apos;P&apos;</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span><span class="preprocessor">#define PTATAGC_CLOCK      &apos;C&apos;</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span><span class="preprocessor">#define PTATAGC_ECHO       &apos;E&apos;</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span><span class="preprocessor">#define PTATAGC_VETO       &apos;V&apos;</span>
<a name="l00540"></a>00540 <span class="preprocessor"></span><span class="preprocessor">#define PTATAGC_UNKNOWN    &apos;U&apos;</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span>
<a name="l00542"></a>00542   <span class="comment">/* - number of tags and tag name string length */</span>
<a name="l00543"></a>00543 <span class="preprocessor">#define PTAMAXTAGS    16  </span><span class="comment">/* max number of pTA tags for pTA MDU M3 */</span>
<a name="l00544"></a>00544 <span class="preprocessor">#define TDCMAXTAGS16  16  </span><span class="comment">/* max number of pTA tags for TDC MDU T4 */</span>
<a name="l00545"></a>00545 <span class="preprocessor">#define TDCMAXTAGS32  32  </span><span class="comment">/* max number of pTA tags for TDC MDU T5 */</span>
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="preprocessor">#define MAXTAGSTR     12  </span><span class="comment">/* max length of pTA tag strings                  */</span>
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="comment">/* ---------------------------------------------------------------------- */</span>
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="comment">/*   basic structure of a MidasDUmp file witten by pTA front end</span>
<a name="l00552"></a>00552 <span class="comment"></span>
<a name="l00553"></a>00553 <span class="comment">      // write header information</span>
<a name="l00554"></a>00554 <span class="comment">      fwrite(&amp;gpTAfhead, gpTAfhead.NumBytesHeader, 1, fp);</span>
<a name="l00555"></a>00555 <span class="comment"></span>
<a name="l00556"></a>00556 <span class="comment">      // write settings information</span>
<a name="l00557"></a>00557 <span class="comment">      fwrite(&amp;gpTAset, gpTAfhead.NumBytesSettings, 1, fp);</span>
<a name="l00558"></a>00558 <span class="comment"></span>
<a name="l00559"></a>00559 <span class="comment">      // write statistic</span>
<a name="l00560"></a>00560 <span class="comment">      fwrite(&amp;gpTAstattot, gpTAfhead.NumBytesStatistics, 1, fp);</span>
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">      for (i = 0; i &lt; PTAMAXTAGS; i++) {</span>
<a name="l00563"></a>00563 <span class="comment">        // write tag record of histogram</span>
<a name="l00564"></a>00564 <span class="comment">        fwrite(&amp;gpTAset.tag[i], gpTAfhead.NumBytesTag, 1, fp);</span>
<a name="l00565"></a>00565 <span class="comment"></span>
<a name="l00566"></a>00566 <span class="comment">        // write histogram data</span>
<a name="l00567"></a>00567 <span class="comment">        if ((gpTAset.tag[i].Type == PTATAGC_POSITRON) &amp;&amp;</span>
<a name="l00568"></a>00568 <span class="comment">            ((nbins =(gpTAset.tag[i].Histomaxb - gpTAset.tag[i].Histominb + 1)) &gt; 1) &amp;&amp;</span>
<a name="l00569"></a>00569 <span class="comment">            (gpHistogram[i] != NULL))</span>
<a name="l00570"></a>00570 <span class="comment">            fwrite(gpHistogram[i], sizeof(unsigned int), nbins, fp);</span>
<a name="l00571"></a>00571 <span class="comment">      }</span>
<a name="l00572"></a>00572 <span class="comment"></span>
<a name="l00573"></a>00573 <span class="comment"></span>
<a name="l00574"></a>00574 <span class="comment"> */</span>
<a name="l00575"></a>00575     <span class="comment">/* - general file header part used to save runs */</span>
<a name="l00576"></a>00576 <span class="keyword">typedef</span> <span class="keyword">struct </span>_FeFileHeaderRec {
<a name="l00577"></a>00577   <span class="keywordtype">char</span>   FmtId;
<a name="l00578"></a>00578   <span class="keywordtype">char</span>   FmtVersion;
<a name="l00579"></a>00579   <span class="keywordtype">char</span>   StartDate[DATESTR];
<a name="l00580"></a>00580   <span class="keywordtype">char</span>   StartTime[TIMESTR];
<a name="l00581"></a>00581   <span class="keywordtype">char</span>   EndDate[DATESTR];
<a name="l00582"></a>00582   <span class="keywordtype">char</span>   EndTime[TIMESTR];
<a name="l00583"></a>00583   Int32  RunNumber;
<a name="l00584"></a>00584   Int32  FileVersion;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586   <span class="comment">/* information for automatic data conversion */</span>
<a name="l00587"></a>00587   <span class="keywordtype">char</span>   RunTitle[TITLESTR+1];
<a name="l00588"></a>00588   <span class="keywordtype">char</span>   RunSubTitle[SUBTITLESTR+1];
<a name="l00589"></a>00589   <span class="keywordtype">char</span>   DataFormat[DATAFORMATSTR];<span class="comment">// data format (automatically converted to)</span>
<a name="l00590"></a>00590   Int32  HistoResolution;          <span class="comment">// TDC resolution factor for target format</span>
<a name="l00591"></a>00591                                    <span class="comment">// or pTA timespan</span>
<a name="l00592"></a>00592   Int32  BinOffset;
<a name="l00593"></a>00593   Int32  BinsPerHistogram;
<a name="l00594"></a>00594   Int32  NumberOfDetectors;
<a name="l00595"></a>00595   <span class="keywordtype">char</span> DetectorNumberList[DETECTLISTSTR]; <span class="comment">// list of detectors to be converted</span>
<a name="l00596"></a>00596                                           <span class="comment">// to the target data format</span>
<a name="l00597"></a>00597   <span class="comment">/* additional information */</span>
<a name="l00598"></a>00598   <span class="keywordtype">char</span> MeanTemp[TEMPLISTSTR];
<a name="l00599"></a>00599   <span class="keywordtype">char</span> TempDev[TEMPLISTSTR];
<a name="l00600"></a>00600 } FeFileHeaderRec, *FeFileHeaderPtr;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602   <span class="comment">/* - pTA file header */</span>
<a name="l00603"></a>00603 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTAFileHeaderRec {
<a name="l00604"></a>00604   FeFileHeaderRec Header;
<a name="l00605"></a>00605   Int32  BinSize;
<a name="l00606"></a>00606   Int32  NumBytesHeader;
<a name="l00607"></a>00607   Int32  NumBytesSettings;
<a name="l00608"></a>00608   Int32  NumBytesTag;
<a name="l00609"></a>00609   Int32  NumBytesStatistics;
<a name="l00610"></a>00610 } pTAFileHeaderRec, *pTAFileHeaderPtr;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="comment">/* - pTA tag information */</span>
<a name="l00613"></a>00613 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTATagRec {
<a name="l00614"></a>00614   <span class="keywordtype">char</span>  Label[MAXTAGSTR];
<a name="l00615"></a>00615   <span class="keywordtype">char</span>  Type;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="comment">/* original pTA list mode (raw) time difference */</span>
<a name="l00618"></a>00618   Int32   Rawminps;
<a name="l00619"></a>00619   Int32   Rawmaxps;
<a name="l00620"></a>00620   Int32   Rawminb; <span class="comment">/* bin range may be 0-262143 (or larger if PTAMODE_CLOCK) */</span>
<a name="l00621"></a>00621   Int32   Rawmaxb;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="comment">/* a modified time difference (binning) may be stored in histo */</span>
<a name="l00624"></a>00624   Int32   Histominps;
<a name="l00625"></a>00625   Int32   Histomaxps;
<a name="l00626"></a>00626   Int32   Histominb;
<a name="l00627"></a>00627   Int32   Histomaxb;
<a name="l00628"></a>00628   Int32   t0b;   <span class="comment">/* t0, tfirst tlast in [bins] for automatic data conversion */</span>
<a name="l00629"></a>00629   Int32   tfb;   <span class="comment">/* NOTE: t0b, tfb, tlb are in bin units of the target format!! */</span>
<a name="l00630"></a>00630   Int32   tlb;
<a name="l00631"></a>00631 } pTATagRec, *pTATagPtr;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="comment">/* - pTA settings relevant for td_musr for pTA M3 format*/</span>
<a name="l00634"></a>00634 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTASettingsRec {
<a name="l00635"></a>00635   Int32 mode;     <span class="comment">/* PTAMODE_NORMAL[+PTAMODE_CLOCK] or PTAMODE_ECHO          */</span>
<a name="l00636"></a>00636   Int32 preps;    <span class="comment">/* pre  pile up [ps] (nearest integer)         ; info only */</span>
<a name="l00637"></a>00637   Int32 posps;    <span class="comment">/* post pile up [ps]                           ; info only */</span>
<a name="l00638"></a>00638   Int32 preb;     <span class="comment">/* pre  pile up [bins]                                     */</span>
<a name="l00639"></a>00639   Int32 posb;     <span class="comment">/* post pile up [bins]                                     */</span>
<a name="l00640"></a>00640   Int32 ecsps;    <span class="comment">/* muon echo signal delay (PTAMODE_ECHO) [ps]  ; info only */</span>
<a name="l00641"></a>00641   Int32 ectps;    <span class="comment">/* muon echo tolerance    (PTAMODE_ECHO) [ps]  ; info only */</span>
<a name="l00642"></a>00642   Int32 ecsb;     <span class="comment">/* muon echo signal delay (PTAMODE_ECHO) [bins]            */</span>
<a name="l00643"></a>00643   Int32 ectb;     <span class="comment">/* muon echo tolerance    (PTAMODE_ECHO) [bins]            */</span>
<a name="l00644"></a>00644   Int32 timespan; <span class="comment">/* pTA timespan                                            */</span>
<a name="l00645"></a>00645   Int32 minrate;  <span class="comment">/* minimum event rate                                      */</span>
<a name="l00646"></a>00646   Int32 eortag;   <span class="comment">/* end of run tag number                                   */</span>
<a name="l00647"></a>00647   Int32 eorlim;   <span class="comment">/* end of run limit                                        */</span>
<a name="l00648"></a>00648   pTATagRec tag[PTAMAXTAGS];
<a name="l00649"></a>00649 } pTASettingsRec, *pTASettingsPtr;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <span class="comment">/* - pTA settings relevant for td_musr for TDC T4 format */</span>
<a name="l00652"></a>00652 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTATDCSettingsRec {
<a name="l00653"></a>00653   Int32 mode;     <span class="comment">/* PTAMODE_NORMAL[+PTAMODE_CLOCK] or PTAMODE_ECHO          */</span>
<a name="l00654"></a>00654   Int32 preps;    <span class="comment">/* pre  pile up [ps] (nearest integer)         ; info only */</span>
<a name="l00655"></a>00655   Int32 posps;    <span class="comment">/* post pile up [ps]                           ; info only */</span>
<a name="l00656"></a>00656   Int32 preb;     <span class="comment">/* pre  pile up [bins]                                     */</span>
<a name="l00657"></a>00657   Int32 posb;     <span class="comment">/* post pile up [bins]                                     */</span>
<a name="l00658"></a>00658   Int32 ecsps;    <span class="comment">/* muon echo signal delay (PTAMODE_ECHO) [ps]  ; info only */</span>
<a name="l00659"></a>00659   Int32 ectps;    <span class="comment">/* muon echo tolerance    (PTAMODE_ECHO) [ps]  ; info only */</span>
<a name="l00660"></a>00660   Int32 ecsb;     <span class="comment">/* muon echo signal delay (PTAMODE_ECHO) [bins]            */</span>
<a name="l00661"></a>00661   Int32 ectb;     <span class="comment">/* muon echo tolerance    (PTAMODE_ECHO) [bins]            */</span>
<a name="l00662"></a>00662   Int32 resolutioncode; <span class="comment">/* type specific TDC resolution code 25 ps, 200ps    */</span>
<a name="l00663"></a>00663   Int32 minrate;  <span class="comment">/* minimum event rate                                      */</span>
<a name="l00664"></a>00664   Int32 eortag;   <span class="comment">/* end of run tag number                                   */</span>
<a name="l00665"></a>00665   Int32 eorlim;   <span class="comment">/* end of run limit                                        */</span>
<a name="l00666"></a>00666   pTATagRec tag[TDCMAXTAGS16];
<a name="l00667"></a>00667 } pTATDCSettingsRec, *pTATDCSettingsPtr;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   <span class="comment">/* - pTA settings relevant for td_musr for TDC T5 format */</span>
<a name="l00670"></a>00670 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTATDC32SettingsRec {
<a name="l00671"></a>00671   Int32 mode;     <span class="comment">/* PTAMODE_NORMAL[+PTAMODE_CLOCK] or PTAMODE_ECHO          */</span>
<a name="l00672"></a>00672   Int32 preps;    <span class="comment">/* pre  pile up [ps] (nearest integer)         ; info only */</span>
<a name="l00673"></a>00673   Int32 posps;    <span class="comment">/* post pile up [ps]                           ; info only */</span>
<a name="l00674"></a>00674   Int32 preb;     <span class="comment">/* pre  pile up [bins]                                     */</span>
<a name="l00675"></a>00675   Int32 posb;     <span class="comment">/* post pile up [bins]                                     */</span>
<a name="l00676"></a>00676   Int32 ecsps;    <span class="comment">/* muon echo signal delay (PTAMODE_ECHO) [ps]  ; info only */</span>
<a name="l00677"></a>00677   Int32 ectps;    <span class="comment">/* muon echo tolerance    (PTAMODE_ECHO) [ps]  ; info only */</span>
<a name="l00678"></a>00678   Int32 ecsb;     <span class="comment">/* muon echo signal delay (PTAMODE_ECHO) [bins]            */</span>
<a name="l00679"></a>00679   Int32 ectb;     <span class="comment">/* muon echo tolerance    (PTAMODE_ECHO) [bins]            */</span>
<a name="l00680"></a>00680   Int32 resolutioncode; <span class="comment">/* type specific TDC resolution code 25 ps, 200ps    */</span>
<a name="l00681"></a>00681   Int32 minrate;  <span class="comment">/* minimum event rate                                      */</span>
<a name="l00682"></a>00682   Int32 eortag;   <span class="comment">/* end of run tag number                                   */</span>
<a name="l00683"></a>00683   Int32 eorlim;   <span class="comment">/* end of run limit                                        */</span>
<a name="l00684"></a>00684   pTATagRec tag[TDCMAXTAGS32];
<a name="l00685"></a>00685 } pTATDC32SettingsRec, *pTATDC32SettingsPtr;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   <span class="comment">/* - pTA td_musr statistic for pTA M3 format */</span>
<a name="l00688"></a>00688 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTAStatisticRec {
<a name="l00689"></a>00689   Int32 time;
<a name="l00690"></a>00690   Int32 ESum;
<a name="l00691"></a>00691   Int32 EMuon;
<a name="l00692"></a>00692   Int32 EPositron;
<a name="l00693"></a>00693   Int32 EClock;
<a name="l00694"></a>00694   Int32 EEcho;
<a name="l00695"></a>00695   Int32 EVeto;
<a name="l00696"></a>00696   Int32 EUnknown;
<a name="l00697"></a>00697   Int32 EMMPileup;
<a name="l00698"></a>00698   Int32 EPrePileup;                         <span class="comment">/* M-P-M Pileup */</span>
<a name="l00699"></a>00699   Int32 EPostPileup;                        <span class="comment">/* M-M-P Pileup */</span>
<a name="l00700"></a>00700   Int32 EHOverflow;
<a name="l00701"></a>00701   Int32 EDoublePositron;
<a name="l00702"></a>00702   Int32 EAccepted;
<a name="l00703"></a>00703   Int32 TagScaler[PTAMAXTAGS];
<a name="l00704"></a>00704   Int32 HistogramScaler[PTAMAXTAGS];
<a name="l00705"></a>00705   Int32 EOverFlowBits;  <span class="comment">/* overflow flag bits for time and event counter overflow*/</span>
<a name="l00706"></a>00706   Int32 TSOverFlowBits; <span class="comment">/* overflow flag bits for tag scaler overflow            */</span>
<a name="l00707"></a>00707   Int32 HSOverFlowBits; <span class="comment">/* overflow flag bits for histogram scaler overflow      */</span>
<a name="l00708"></a>00708   Int32 HOverFlowBits;  <span class="comment">/* overflow flag bits for histogram overflow             */</span>
<a name="l00709"></a>00709 } pTAStatisticRec, *pTAStatisticPtr;
<a name="l00710"></a>00710 
<a name="l00711"></a>00711   <span class="comment">/* - pTA td_musr statistic for TDC T4 format */</span>
<a name="l00712"></a>00712 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTATDCStatisticRec {
<a name="l00713"></a>00713   Int32 time;
<a name="l00714"></a>00714   Int32 ESum;
<a name="l00715"></a>00715   Int32 EMuon;
<a name="l00716"></a>00716   Int32 EPositron;
<a name="l00717"></a>00717   Int32 EClock;
<a name="l00718"></a>00718   Int32 EEcho;
<a name="l00719"></a>00719   Int32 EVeto;
<a name="l00720"></a>00720   Int32 EUnknown;
<a name="l00721"></a>00721   Int32 EMMPileup;
<a name="l00722"></a>00722   Int32 EPrePileup;                         <span class="comment">/* M-P-M Pileup */</span>
<a name="l00723"></a>00723   Int32 EPostPileup;                        <span class="comment">/* M-M-P Pileup */</span>
<a name="l00724"></a>00724   Int32 EHOverflow;
<a name="l00725"></a>00725   Int32 EDoublePositron;
<a name="l00726"></a>00726   Int32 EAccepted;
<a name="l00727"></a>00727   Int32 TagScaler[TDCMAXTAGS16];
<a name="l00728"></a>00728   Int32 HistogramScaler[TDCMAXTAGS16];
<a name="l00729"></a>00729   Int32 EOverFlowBits;  <span class="comment">/* overflow flag bits for time and event counter overflow*/</span>
<a name="l00730"></a>00730   Int32 TSOverFlowBits; <span class="comment">/* overflow flag bits for tag scaler overflow            */</span>
<a name="l00731"></a>00731   Int32 HSOverFlowBits; <span class="comment">/* overflow flag bits for histogram scaler overflow      */</span>
<a name="l00732"></a>00732   Int32 HOverFlowBits;  <span class="comment">/* overflow flag bits for histogram overflow             */</span>
<a name="l00733"></a>00733 } pTATDCStatisticRec, *pTATDCStatisticPtr;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735   <span class="comment">/* - pTA td_musr statistic for TDC T5 format*/</span>
<a name="l00736"></a>00736 <span class="keyword">typedef</span> <span class="keyword">struct </span>_pTATDC32StatisticRec {
<a name="l00737"></a>00737   Int32 time;
<a name="l00738"></a>00738   Int32 ESum;
<a name="l00739"></a>00739   Int32 EMuon;
<a name="l00740"></a>00740   Int32 EPositron;
<a name="l00741"></a>00741   Int32 EClock;
<a name="l00742"></a>00742   Int32 EEcho;
<a name="l00743"></a>00743   Int32 EVeto;
<a name="l00744"></a>00744   Int32 EUnknown;
<a name="l00745"></a>00745   Int32 EMMPileup;
<a name="l00746"></a>00746   Int32 EPrePileup;                         <span class="comment">/* M-P-M Pileup */</span>
<a name="l00747"></a>00747   Int32 EPostPileup;                        <span class="comment">/* M-M-P Pileup */</span>
<a name="l00748"></a>00748   Int32 EHOverflow;
<a name="l00749"></a>00749   Int32 EDoublePositron;
<a name="l00750"></a>00750   Int32 EAccepted;
<a name="l00751"></a>00751   Int32 TagScaler[TDCMAXTAGS32];
<a name="l00752"></a>00752   Int32 HistogramScaler[TDCMAXTAGS32];
<a name="l00753"></a>00753   Int32 EOverFlowBits;  <span class="comment">/* overflow flag bits for time and event counter overflow*/</span>
<a name="l00754"></a>00754   Int32 TSOverFlowBits; <span class="comment">/* overflow flag bits for tag scaler overflow            */</span>
<a name="l00755"></a>00755   Int32 HSOverFlowBits; <span class="comment">/* overflow flag bits for histogram scaler overflow      */</span>
<a name="l00756"></a>00756   Int32 HOverFlowBits;  <span class="comment">/* overflow flag bits for histogram overflow             */</span>
<a name="l00757"></a>00757 } pTATDC32StatisticRec, *pTATDC32StatisticPtr;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="comment">/* ---------------------------------------------------------------------- */</span>
<a name="l00760"></a>00760 
<a name="l00775"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a1db93f6e3dcf6202d29c1a133429ee29">00775</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a1db93f6e3dcf6202d29c1a133429ee29" title="Method to read a MuSR MDU file.">MuSR_td_PSI_bin::readmdu</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * fileName)
<a name="l00776"></a>00776   {
<a name="l00777"></a>00777     ifstream  file_name ;
<a name="l00778"></a>00778     <span class="keywordtype">int</span>       i, j ;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(Int32) != 4)
<a name="l00783"></a>00783     {
<a name="l00784"></a>00784       readstatus  = <span class="stringliteral">&quot;ERROR Sizeof( Int32 ) data type is not 4 bytes&quot;</span>;
<a name="l00785"></a>00785       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     filename    = fileName;
<a name="l00789"></a>00789 
<a name="l00790"></a>00790     file_name.open(fileName, ios_base::binary);  <span class="comment">// open PSI bin file</span>
<a name="l00791"></a>00791     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00792"></a>00792     {
<a name="l00793"></a>00793       readstatus  = <span class="stringliteral">&quot;ERROR Open &quot;</span>+filename+<span class="stringliteral">&quot; failed!&quot;</span>;
<a name="l00794"></a>00794       <span class="keywordflow">return</span> 1;            <span class="comment">// ERROR open failed</span>
<a name="l00795"></a>00795     }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797     pTAFileHeaderRec      gpTAfhead;
<a name="l00798"></a>00798     <span class="comment">//FeFileHeaderPtr     gpFehead  = &amp;gpTAfhead.Header;</span>
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAfhead, <span class="keyword">sizeof</span> gpTAfhead) ;    <span class="comment">// read header into buffer</span>
<a name="l00801"></a>00801     <span class="keywordflow">if</span> (file_name.fail())
<a name="l00802"></a>00802     {
<a name="l00803"></a>00803       file_name.close();
<a name="l00804"></a>00804       readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; header failed!&quot;</span>;
<a name="l00805"></a>00805       <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00806"></a>00806     }
<a name="l00807"></a>00807                                                <span class="comment">// fill header data into member variables</span>
<a name="l00808"></a>00808     format_id[0] = gpTAfhead.Header.FmtId;
<a name="l00809"></a>00809     format_id[1] = gpTAfhead.Header.FmtVersion;
<a name="l00810"></a>00810     format_id[2] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     <span class="keywordflow">if</span> ((strcmp(format_id,<span class="stringliteral">&quot;M3&quot;</span>) != 0) &amp;&amp; (strcmp(format_id,<span class="stringliteral">&quot;T4&quot;</span>) != 0) &amp;&amp;
<a name="l00813"></a>00813         (strcmp(format_id,<span class="stringliteral">&quot;T5&quot;</span>) != 0))
<a name="l00814"></a>00814     {
<a name="l00815"></a>00815       file_name.close();
<a name="l00816"></a>00816       readstatus  = <span class="stringliteral">&quot;ERROR Unknown file format in &quot;</span>+filename+<span class="stringliteral">&quot;!&quot;</span>;
<a name="l00817"></a>00817       <span class="keywordflow">return</span> 2 ;                                 <span class="comment">// ERROR unsupported version</span>
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTAFileHeaderRec) != gpTAfhead.NumBytesHeader)
<a name="l00821"></a>00821     {
<a name="l00822"></a>00822       file_name.close();
<a name="l00823"></a>00823       readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTAFileHeaderRec size&quot;</span>;
<a name="l00824"></a>00824       <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     <span class="comment">// header size OK read header information</span>
<a name="l00828"></a>00828     strncpy(sample,&amp;gpTAfhead.Header.RunTitle[0],10) ;
<a name="l00829"></a>00829             sample[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831     strncpy(temp,  &amp;gpTAfhead.Header.RunTitle[10],10) ;
<a name="l00832"></a>00832             temp[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     strncpy(field, &amp;gpTAfhead.Header.RunTitle[20],10) ;
<a name="l00835"></a>00835             field[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     strncpy(orient,&amp;gpTAfhead.Header.RunTitle[30],10) ;
<a name="l00838"></a>00838             orient[10] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     strncpy(comment,&amp;gpTAfhead.Header.RunSubTitle[0],62) ;
<a name="l00841"></a>00841             comment[62] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843     strncpy(&amp;date_start[0],&amp;gpTAfhead.Header.StartDate[0],7) ;
<a name="l00844"></a>00844     strncpy(&amp;date_start[7],&amp;gpTAfhead.Header.StartDate[9],2) ;
<a name="l00845"></a>00845             date_start[9] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847     strncpy(&amp;date_stop[0],&amp;gpTAfhead.Header.EndDate[0],7) ;
<a name="l00848"></a>00848     strncpy(&amp;date_stop[7],&amp;gpTAfhead.Header.EndDate[9],2) ;
<a name="l00849"></a>00849             date_stop[9] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     strncpy(time_start,&amp;gpTAfhead.Header.StartTime[0],8) ;
<a name="l00852"></a>00852             time_start[8] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854     strncpy(time_stop,&amp;gpTAfhead.Header.EndTime[0],8) ;
<a name="l00855"></a>00855             time_stop[8] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857     num_run = gpTAfhead.Header.RunNumber;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTATagRec) != gpTAfhead.NumBytesTag)
<a name="l00860"></a>00860     {
<a name="l00861"></a>00861       file_name.close();
<a name="l00862"></a>00862       readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTATagRec size&quot;</span>;
<a name="l00863"></a>00863       <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;Header.MeanTemp = &quot;</span> &lt;&lt; gpTAfhead.Header.MeanTemp &lt;&lt; endl;
<a name="l00868"></a>00868     cout &lt;&lt; <span class="stringliteral">&quot;Header.TempDev  = &quot;</span> &lt;&lt; gpTAfhead.Header.TempDev &lt;&lt; endl;
<a name="l00869"></a>00869 <span class="preprocessor">#endif</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span>
<a name="l00871"></a>00871     <span class="comment">// read temperature deviation from header string (td0 [td1 [td2 [td3]]])</span>
<a name="l00872"></a>00872     number_temper = sscanf(gpTAfhead.Header.TempDev,<span class="stringliteral">&quot;%f %f %f %f&quot;</span>,
<a name="l00873"></a>00873                            &amp;temp_deviation[0], &amp;temp_deviation[1], &amp;temp_deviation[2],
<a name="l00874"></a>00874                            &amp;temp_deviation[3]);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     <span class="comment">// fill unused</span>
<a name="l00877"></a>00877     <span class="keywordflow">for</span> (i=number_temper; i&lt;MAXTEMPER; i++)
<a name="l00878"></a>00878       temp_deviation[i] = 0.f;
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     <span class="comment">// read temperature from header string (t0 [t1 [t2 [t3]]])</span>
<a name="l00881"></a>00881     number_temper = sscanf(gpTAfhead.Header.MeanTemp,<span class="stringliteral">&quot;%f %f %f %f&quot;</span>,
<a name="l00882"></a>00882                            &amp;temper[0], &amp;temper[1], &amp;temper[2], &amp;temper[3]);
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     <span class="comment">// fill unused</span>
<a name="l00885"></a>00885     <span class="keywordflow">for</span> (i=number_temper; i&lt;MAXTEMPER; i++)
<a name="l00886"></a>00886     {
<a name="l00887"></a>00887       temper[i] = 0.f;
<a name="l00888"></a>00888       temp_deviation[i] = 0.f;
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l00892"></a>00892 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;Header.DataFormat = &quot;</span> &lt;&lt; gpTAfhead.Header.DataFormat &lt;&lt; endl;
<a name="l00893"></a>00893     cout &lt;&lt; <span class="stringliteral">&quot;Header.HistoResolution = &quot;</span> &lt;&lt; gpTAfhead.Header.HistoResolution &lt;&lt; endl;
<a name="l00894"></a>00894     cout &lt;&lt; <span class="stringliteral">&quot;Header.BinOffset = &quot;</span> &lt;&lt; gpTAfhead.Header.BinOffset &lt;&lt; endl;
<a name="l00895"></a>00895     cout &lt;&lt; <span class="stringliteral">&quot;Header.BinsPerHistogram = &quot;</span> &lt;&lt; gpTAfhead.Header.BinsPerHistogram &lt;&lt; endl;
<a name="l00896"></a>00896     cout &lt;&lt; <span class="stringliteral">&quot;Header.NumberOfDetectors = &quot;</span> &lt;&lt; gpTAfhead.Header.NumberOfDetectors &lt;&lt; endl;
<a name="l00897"></a>00897     cout &lt;&lt; <span class="stringliteral">&quot;Header.DetectorNumberList = &quot;</span> &lt;&lt; gpTAfhead.Header.DetectorNumberList &lt;&lt; endl;
<a name="l00898"></a>00898 <span class="preprocessor">#endif</span>
<a name="l00899"></a>00899 <span class="preprocessor"></span>
<a name="l00900"></a>00900     <span class="comment">// process detector list in gpTAfhead.Header.NumberOfDetectors</span>
<a name="l00901"></a>00901     <span class="comment">// for pTA only histograms of selected detectors are valid</span>
<a name="l00902"></a>00902     <span class="keywordtype">bool</span> selected[MAXHISTO];
<a name="l00903"></a>00903 
<a name="l00904"></a>00904     <span class="keywordflow">for</span> (i=0; i &lt; MAXHISTO; i++)
<a name="l00905"></a>00905       selected[i] = <span class="keyword">false</span>;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     <span class="keywordflow">for</span> (i=0,j=0; i &lt;= (int)strlen(gpTAfhead.Header.DetectorNumberList); i++) {
<a name="l00908"></a>00908       <span class="keywordflow">if</span> ((gpTAfhead.Header.DetectorNumberList[i] == <span class="charliteral">&apos; &apos;</span>) ||
<a name="l00909"></a>00909           (gpTAfhead.Header.DetectorNumberList[i] == <span class="charliteral">&apos;\0&apos;</span>)) {
<a name="l00910"></a>00910         <span class="keywordtype">int</span> it;
<a name="l00911"></a>00911         <span class="keywordflow">if</span> (sscanf(&amp;gpTAfhead.Header.DetectorNumberList[j],<span class="stringliteral">&quot;%d&quot;</span>,&amp;it) == 1) {
<a name="l00912"></a>00912           j = i+1; <span class="comment">// assume next char is start of next number</span>
<a name="l00913"></a>00913           <span class="keywordflow">if</span> ((it &gt;= 0) &amp;&amp; (it &lt; MAXHISTO)) {
<a name="l00914"></a>00914             selected[it] = <span class="keyword">true</span>;
<a name="l00915"></a>00915 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l00916"></a>00916 <span class="preprocessor"></span>            cout &lt;&lt; <span class="stringliteral">&quot;Histogram &quot;</span> &lt;&lt; it &lt;&lt; <span class="stringliteral">&quot; is selected &quot;</span> &lt;&lt; endl;
<a name="l00917"></a>00917 <span class="preprocessor">#endif</span>
<a name="l00918"></a>00918 <span class="preprocessor"></span>          } <span class="keywordflow">else</span> {
<a name="l00919"></a>00919             cout &lt;&lt; <span class="stringliteral">&quot;error &quot;</span> &lt;&lt; it &lt;&lt; <span class="stringliteral">&quot; is out of range |0 - &quot;</span> &lt;&lt; MAXHISTO-1 &lt;&lt; <span class="stringliteral">&quot;|&quot;</span>
<a name="l00920"></a>00920                  &lt;&lt;endl;
<a name="l00921"></a>00921           }
<a name="l00922"></a>00922         } <span class="keywordflow">else</span> {
<a name="l00923"></a>00923           cout &lt;&lt; <span class="stringliteral">&quot;error reading &quot;</span> &lt;&lt; &amp;gpTAfhead.Header.DetectorNumberList[j] &lt;&lt; endl;
<a name="l00924"></a>00924         }
<a name="l00925"></a>00925       }
<a name="l00926"></a>00926     }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928     <span class="keywordtype">int</span> tothist = 0;
<a name="l00929"></a>00929     <span class="keywordtype">int</span> resolutionfactor = 1;
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="comment">// ---- process version specific settings and total statistics</span>
<a name="l00932"></a>00932     <span class="keywordflow">if</span>        (strcmp(format_id,<span class="stringliteral">&quot;M3&quot;</span>) == 0)
<a name="l00933"></a>00933     {
<a name="l00934"></a>00934 
<a name="l00935"></a>00935       <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTASettingsRec) != gpTAfhead.NumBytesSettings)
<a name="l00936"></a>00936       {
<a name="l00937"></a>00937         file_name.close();
<a name="l00938"></a>00938         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTASettingsRec size&quot;</span>;
<a name="l00939"></a>00939         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00940"></a>00940       }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942       <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTAStatisticRec) != gpTAfhead.NumBytesStatistics)
<a name="l00943"></a>00943       {
<a name="l00944"></a>00944         file_name.close();
<a name="l00945"></a>00945         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTAStatisticRec size&quot;</span>;
<a name="l00946"></a>00946         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l00947"></a>00947       }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949       pTASettingsRec   gpTAsetpta;
<a name="l00950"></a>00950       pTAStatisticRec  gpTAstattotpta;
<a name="l00951"></a>00951 
<a name="l00952"></a>00952       tothist = PTAMAXTAGS;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954       file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAsetpta, <span class="keyword">sizeof</span> gpTAsetpta);<span class="comment">//read settings into buffer</span>
<a name="l00955"></a>00955       <span class="keywordflow">if</span> (file_name.fail())
<a name="l00956"></a>00956       {
<a name="l00957"></a>00957         file_name.close();
<a name="l00958"></a>00958         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; settings failed!&quot;</span>;
<a name="l00959"></a>00959         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading settings failed</span>
<a name="l00960"></a>00960       }
<a name="l00961"></a>00961 
<a name="l00962"></a>00962       <span class="comment">// read stat into buffer</span>
<a name="l00963"></a>00963       file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAstattotpta, <span class="keyword">sizeof</span> gpTAstattotpta) ; 
<a name="l00964"></a>00964       <span class="keywordflow">if</span> (file_name.fail())
<a name="l00965"></a>00965       {
<a name="l00966"></a>00966         file_name.close();
<a name="l00967"></a>00967         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; statistics failed!&quot;</span>;
<a name="l00968"></a>00968         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading statistics failed</span>
<a name="l00969"></a>00969       }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971       number_scaler = PTAMAXTAGS;
<a name="l00972"></a>00972       <span class="keywordflow">for</span> (i=0; i &lt; number_scaler; i++)
<a name="l00973"></a>00973       {
<a name="l00974"></a>00974         strncpy(labels_scalers[i],gpTAsetpta.tag[i].Label,MAXLABELSIZE);
<a name="l00975"></a>00975         labels_scalers[i][MAXLABELSIZE-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         scalers[i] = gpTAstattotpta.TagScaler[i];
<a name="l00978"></a>00978       }
<a name="l00979"></a>00979 
<a name="l00980"></a>00980       <span class="keywordtype">int</span> timespan;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982       resolutionfactor = 1;
<a name="l00983"></a>00983       timespan = gpTAfhead.Header.HistoResolution; <span class="comment">// target timespan (PSIBIN)</span>
<a name="l00984"></a>00984                                                    <span class="comment">// t0, fg, lg</span>
<a name="l00985"></a>00985       <span class="keywordflow">if</span>      (gpTAsetpta.timespan == 11) <span class="comment">// pta timespan</span>
<a name="l00986"></a>00986         bin_width = 0.000625;
<a name="l00987"></a>00987       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsetpta.timespan == 10)
<a name="l00988"></a>00988         bin_width = 0.0003125;
<a name="l00989"></a>00989       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsetpta.timespan ==  9)
<a name="l00990"></a>00990         bin_width = 0.00015625;
<a name="l00991"></a>00991       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsetpta.timespan ==  8)
<a name="l00992"></a>00992         bin_width = 0.000078125;
<a name="l00993"></a>00993       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsetpta.timespan ==  7)
<a name="l00994"></a>00994         bin_width = 0.0000390625;
<a name="l00995"></a>00995       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsetpta.timespan ==  6)
<a name="l00996"></a>00996         bin_width = 0.00001953125;
<a name="l00997"></a>00997       <span class="keywordflow">else</span>
<a name="l00998"></a>00998       {
<a name="l00999"></a>00999         file_name.close();
<a name="l01000"></a>01000         readstatus  = <span class="stringliteral">&quot;ERROR &quot;</span>+filename+<span class="stringliteral">&quot; settings resolution code failed!&quot;</span>;
<a name="l01001"></a>01001         <span class="keywordflow">return</span> 1;                                   <span class="comment">// ERROR reading settings failed</span>
<a name="l01002"></a>01002       }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004       <span class="keywordflow">if</span> (timespan+8-gpTAsetpta.timespan &lt; 0)
<a name="l01005"></a>01005       {
<a name="l01006"></a>01006         <span class="comment">// NIY error</span>
<a name="l01007"></a>01007       } <span class="keywordflow">else</span> {
<a name="l01008"></a>01008         <span class="comment">/* PSI resolution    pTA timespan    resolution [usec]</span>
<a name="l01009"></a>01009 <span class="comment">         *    -2              6               0.00001953125</span>
<a name="l01010"></a>01010 <span class="comment">         *    -1              7               0.0000390625</span>
<a name="l01011"></a>01011 <span class="comment">         *     0              8               0.000078125</span>
<a name="l01012"></a>01012 <span class="comment">         *     1              9               0.00015625</span>
<a name="l01013"></a>01013 <span class="comment">         *     2             10               0.0003125</span>
<a name="l01014"></a>01014 <span class="comment">         *     3             11               0.000625</span>
<a name="l01015"></a>01015 <span class="comment">         *     4              -               0.00125</span>
<a name="l01016"></a>01016 <span class="comment">         *     5              -               0.0025</span>
<a name="l01017"></a>01017 <span class="comment">         *     6              -               0.005</span>
<a name="l01018"></a>01018 <span class="comment">         */</span>
<a name="l01019"></a>01019         <span class="comment">// resolution factor for binning</span>
<a name="l01020"></a>01020         <span class="keywordflow">for</span> (i=0; i &lt; timespan+8-gpTAsetpta.timespan; i++)
<a name="l01021"></a>01021           resolutionfactor *= 2;
<a name="l01022"></a>01022       }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024       length_histo   = 0;
<a name="l01025"></a>01025       number_histo   = 0;
<a name="l01026"></a>01026       <span class="keywordflow">for</span> (i=0; i&lt;tothist; i++)
<a name="l01027"></a>01027       {
<a name="l01028"></a>01028                   <span class="comment">/* read histogram data */</span>
<a name="l01029"></a>01029         <span class="keywordflow">if</span> (gpTAsetpta.tag[i].Type == PTATAGC_POSITRON)
<a name="l01030"></a>01030         {
<a name="l01031"></a>01031           <span class="keywordtype">int</span> nbins;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>          cout &lt;&lt; <span class="stringliteral">&quot;Tag[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] Histomin = &quot;</span> &lt;&lt; gpTAsetpta.tag[i].Histominb
<a name="l01035"></a>01035                &lt;&lt; <span class="stringliteral">&quot; Histomax = &quot;</span> &lt;&lt; gpTAsetpta.tag[i].Histomaxb &lt;&lt; endl;
<a name="l01036"></a>01036 <span class="preprocessor">#endif</span>
<a name="l01037"></a>01037 <span class="preprocessor"></span>          <span class="comment">// is a histogram there</span>
<a name="l01038"></a>01038           <span class="keywordflow">if</span> ((nbins=(gpTAsetpta.tag[i].Histomaxb-gpTAsetpta.tag[i].Histominb + 1))&gt;1)
<a name="l01039"></a>01039           {
<a name="l01040"></a>01040 
<a name="l01041"></a>01041             <span class="comment">// for pTA only: read histogram only if histogram was selected</span>
<a name="l01042"></a>01042             <span class="keywordflow">if</span> (selected[i])
<a name="l01043"></a>01043             {
<a name="l01044"></a>01044               <span class="comment">// first histo -&gt; take histogram length</span>
<a name="l01045"></a>01045               <span class="keywordflow">if</span> (number_histo == 0)
<a name="l01046"></a>01046                 length_histo = nbins+gpTAsetpta.tag[i].Histominb;
<a name="l01047"></a>01047               <span class="comment">// different histogram length?</span>
<a name="l01048"></a>01048               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length_histo != nbins+gpTAsetpta.tag[i].Histominb)
<a name="l01049"></a>01049               {
<a name="l01050"></a>01050                 cout &lt;&lt; <span class="stringliteral">&quot;Different histogram lengths!&quot;</span> &lt;&lt; endl;
<a name="l01051"></a>01051               }
<a name="l01052"></a>01052               number_histo++;
<a name="l01053"></a>01053             }
<a name="l01054"></a>01054           }
<a name="l01055"></a>01055         }
<a name="l01056"></a>01056       }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058       <span class="comment">// check gpTAfhead.Header.NumberOfDetectors</span>
<a name="l01059"></a>01059       <span class="keywordflow">if</span> (number_histo != gpTAfhead.Header.NumberOfDetectors)
<a name="l01060"></a>01060         cout &lt;&lt; <span class="stringliteral">&quot;Number of found histos &quot;</span> &lt;&lt; number_histo &lt;&lt; <span class="stringliteral">&quot; and number in header &quot;</span>
<a name="l01061"></a>01061              &lt;&lt; gpTAfhead.Header.NumberOfDetectors &lt;&lt; <span class="stringliteral">&quot; differ!&quot;</span> &lt;&lt; endl;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063       <span class="comment">// special case: subtract 1 from stored histogram to get desired histogram length</span>
<a name="l01064"></a>01064       <span class="keywordflow">if</span> (length_histo &gt; 0) length_histo -= 1;
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     }
<a name="l01067"></a>01067     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(format_id,<span class="stringliteral">&quot;T4&quot;</span>) == 0)
<a name="l01068"></a>01068     {
<a name="l01069"></a>01069 
<a name="l01070"></a>01070       <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTATDCSettingsRec) != gpTAfhead.NumBytesSettings)
<a name="l01071"></a>01071       {
<a name="l01072"></a>01072         file_name.close();
<a name="l01073"></a>01073         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTATDCSettingsRec size&quot;</span>;
<a name="l01074"></a>01074         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l01075"></a>01075       }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077       <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTATDCStatisticRec) != gpTAfhead.NumBytesStatistics)
<a name="l01078"></a>01078       {
<a name="l01079"></a>01079         file_name.close();
<a name="l01080"></a>01080         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTATDCStatisticRec size&quot;</span>;
<a name="l01081"></a>01081         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l01082"></a>01082       }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084       pTATDCSettingsRec   gpTAsettdc;
<a name="l01085"></a>01085       pTATDCStatisticRec  gpTAstattottdc;
<a name="l01086"></a>01086 
<a name="l01087"></a>01087       tothist = TDCMAXTAGS16;
<a name="l01088"></a>01088 
<a name="l01089"></a>01089       file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAsettdc, <span class="keyword">sizeof</span> gpTAsettdc);<span class="comment">//read settings into buffer</span>
<a name="l01090"></a>01090       <span class="keywordflow">if</span> (file_name.fail())
<a name="l01091"></a>01091       {
<a name="l01092"></a>01092         file_name.close();
<a name="l01093"></a>01093         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; settings failed!&quot;</span>;
<a name="l01094"></a>01094         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading settings failed</span>
<a name="l01095"></a>01095       }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097       file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAstattottdc, <span class="keyword">sizeof</span> gpTAstattottdc) ; <span class="comment">// read stat into buffer</span>
<a name="l01098"></a>01098       <span class="keywordflow">if</span> (file_name.fail())
<a name="l01099"></a>01099       {
<a name="l01100"></a>01100         file_name.close();
<a name="l01101"></a>01101         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; statistics failed!&quot;</span>;
<a name="l01102"></a>01102         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading statistics failed</span>
<a name="l01103"></a>01103       }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105       number_scaler = TDCMAXTAGS16;
<a name="l01106"></a>01106       <span class="keywordflow">for</span> (i=0; i &lt; number_scaler; i++)
<a name="l01107"></a>01107       {
<a name="l01108"></a>01108         strncpy(labels_scalers[i],gpTAsettdc.tag[i].Label,MAXLABELSIZE);
<a name="l01109"></a>01109         labels_scalers[i][MAXLABELSIZE-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         scalers[i] = gpTAstattottdc.TagScaler[i];
<a name="l01112"></a>01112       }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114       resolutionfactor = gpTAfhead.Header.HistoResolution;
<a name="l01115"></a>01115       <span class="keywordflow">if</span>      (gpTAsettdc.resolutioncode ==  25)
<a name="l01116"></a>01116         bin_width = 0.0000244140625;
<a name="l01117"></a>01117       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsettdc.resolutioncode == 100)
<a name="l01118"></a>01118         bin_width = 0.00009765625;
<a name="l01119"></a>01119       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsettdc.resolutioncode == 200)
<a name="l01120"></a>01120         bin_width = 0.0001953125;
<a name="l01121"></a>01121       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsettdc.resolutioncode == 800)
<a name="l01122"></a>01122         bin_width = 0.0007812500;
<a name="l01123"></a>01123       <span class="keywordflow">else</span>
<a name="l01124"></a>01124       {
<a name="l01125"></a>01125         file_name.close();
<a name="l01126"></a>01126         readstatus  = <span class="stringliteral">&quot;ERROR &quot;</span>+filename+<span class="stringliteral">&quot; settings resolution code failed!&quot;</span>;
<a name="l01127"></a>01127         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading settings failed</span>
<a name="l01128"></a>01128       }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130       length_histo   = 0;
<a name="l01131"></a>01131       number_histo   = 0;
<a name="l01132"></a>01132       <span class="keywordflow">for</span> (i=0; i&lt;tothist; i++)
<a name="l01133"></a>01133       {
<a name="l01134"></a>01134                   <span class="comment">/* read histogram data */</span>
<a name="l01135"></a>01135         <span class="keywordflow">if</span> (gpTAsettdc.tag[i].Type == PTATAGC_POSITRON)
<a name="l01136"></a>01136         {
<a name="l01137"></a>01137           <span class="keywordtype">int</span> nbins;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>          cout &lt;&lt; <span class="stringliteral">&quot;Tag[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] Histomin = &quot;</span> &lt;&lt; gpTAsettdc.tag[i].Histominb
<a name="l01141"></a>01141                &lt;&lt; <span class="stringliteral">&quot; Histomax = &quot;</span> &lt;&lt; gpTAsettdc.tag[i].Histomaxb &lt;&lt; endl;
<a name="l01142"></a>01142 <span class="preprocessor">#endif</span>
<a name="l01143"></a>01143 <span class="preprocessor"></span>          <span class="comment">// is a histogram there</span>
<a name="l01144"></a>01144           <span class="keywordflow">if</span> ((nbins=(gpTAsettdc.tag[i].Histomaxb-gpTAsettdc.tag[i].Histominb + 1))&gt;1)
<a name="l01145"></a>01145           {
<a name="l01146"></a>01146             <span class="comment">// first histo -&gt; take histogram length</span>
<a name="l01147"></a>01147             <span class="keywordflow">if</span> (number_histo == 0)
<a name="l01148"></a>01148               length_histo = nbins+gpTAsettdc.tag[i].Histominb;
<a name="l01149"></a>01149             <span class="comment">// different histogram length?</span>
<a name="l01150"></a>01150             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length_histo != nbins+gpTAsettdc.tag[i].Histominb)
<a name="l01151"></a>01151             {
<a name="l01152"></a>01152               cout &lt;&lt; <span class="stringliteral">&quot;Different histogram lengths!&quot;</span> &lt;&lt; endl;
<a name="l01153"></a>01153             }
<a name="l01154"></a>01154             number_histo++;
<a name="l01155"></a>01155           }
<a name="l01156"></a>01156         }
<a name="l01157"></a>01157       }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159     }
<a name="l01160"></a>01160     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(format_id,<span class="stringliteral">&quot;T5&quot;</span>) == 0)
<a name="l01161"></a>01161     {
<a name="l01162"></a>01162 
<a name="l01163"></a>01163       <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTATDC32SettingsRec) != gpTAfhead.NumBytesSettings)
<a name="l01164"></a>01164       {
<a name="l01165"></a>01165         file_name.close();
<a name="l01166"></a>01166         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTATDC32SettingsRec size&quot;</span>;
<a name="l01167"></a>01167         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l01168"></a>01168       }
<a name="l01169"></a>01169 
<a name="l01170"></a>01170       <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(pTATDC32StatisticRec) != gpTAfhead.NumBytesStatistics)
<a name="l01171"></a>01171       {
<a name="l01172"></a>01172         file_name.close();
<a name="l01173"></a>01173         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; incorrect pTATDC32StatisticRec size&quot;</span>;
<a name="l01174"></a>01174         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading header failed</span>
<a name="l01175"></a>01175       }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177       pTATDC32SettingsRec   gpTAsettdc32;
<a name="l01178"></a>01178       pTATDC32StatisticRec  gpTAstattottdc32;
<a name="l01179"></a>01179 
<a name="l01180"></a>01180       tothist = TDCMAXTAGS32;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182       <span class="comment">// read settings into buffer</span>
<a name="l01183"></a>01183       file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAsettdc32, <span class="keyword">sizeof</span> gpTAsettdc32) ; 
<a name="l01184"></a>01184       <span class="keywordflow">if</span> (file_name.fail())
<a name="l01185"></a>01185       {
<a name="l01186"></a>01186         file_name.close();
<a name="l01187"></a>01187         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; settings failed!&quot;</span>;
<a name="l01188"></a>01188         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading settings failed</span>
<a name="l01189"></a>01189       }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191       <span class="comment">// read stat into buffer</span>
<a name="l01192"></a>01192       file_name.read((<span class="keywordtype">char</span> *)&amp;gpTAstattottdc32, <span class="keyword">sizeof</span> gpTAstattottdc32) ; 
<a name="l01193"></a>01193       <span class="keywordflow">if</span> (file_name.fail())
<a name="l01194"></a>01194       {
<a name="l01195"></a>01195         file_name.close();
<a name="l01196"></a>01196         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; statistics failed!&quot;</span>;
<a name="l01197"></a>01197         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading statistics failed</span>
<a name="l01198"></a>01198       }
<a name="l01199"></a>01199 
<a name="l01200"></a>01200       number_scaler = TDCMAXTAGS32;
<a name="l01201"></a>01201       <span class="keywordflow">for</span> (i=0; i &lt; number_scaler; i++)
<a name="l01202"></a>01202       {
<a name="l01203"></a>01203         strncpy(labels_scalers[i],gpTAsettdc32.tag[i].Label,MAXLABELSIZE);
<a name="l01204"></a>01204         labels_scalers[i][MAXLABELSIZE-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01205"></a>01205 
<a name="l01206"></a>01206         scalers[i] = gpTAstattottdc32.TagScaler[i];
<a name="l01207"></a>01207       }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209       resolutionfactor = gpTAfhead.Header.HistoResolution;
<a name="l01210"></a>01210       <span class="keywordflow">if</span>      (gpTAsettdc32.resolutioncode ==  25)
<a name="l01211"></a>01211         bin_width = 0.0000244140625;
<a name="l01212"></a>01212       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsettdc32.resolutioncode == 100)
<a name="l01213"></a>01213         bin_width = 0.00009765625;
<a name="l01214"></a>01214       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsettdc32.resolutioncode == 200)
<a name="l01215"></a>01215         bin_width = 0.0001953125;
<a name="l01216"></a>01216       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpTAsettdc32.resolutioncode == 800)
<a name="l01217"></a>01217         bin_width = 0.0007812500;
<a name="l01218"></a>01218       <span class="keywordflow">else</span>
<a name="l01219"></a>01219       {
<a name="l01220"></a>01220         file_name.close();
<a name="l01221"></a>01221         readstatus  = <span class="stringliteral">&quot;ERROR &quot;</span>+filename+<span class="stringliteral">&quot; settings resolution code failed!&quot;</span>;
<a name="l01222"></a>01222         <span class="keywordflow">return</span> 1;                                  <span class="comment">// ERROR reading settings failed</span>
<a name="l01223"></a>01223       }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225       length_histo   = 0;
<a name="l01226"></a>01226       number_histo   = 0;
<a name="l01227"></a>01227       <span class="keywordflow">for</span> (i=0; i&lt;tothist; i++)
<a name="l01228"></a>01228       {
<a name="l01229"></a>01229                   <span class="comment">/* read histogram data */</span>
<a name="l01230"></a>01230         <span class="keywordflow">if</span> (gpTAsettdc32.tag[i].Type == PTATAGC_POSITRON)
<a name="l01231"></a>01231         {
<a name="l01232"></a>01232           <span class="keywordtype">int</span> nbins;
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l01235"></a>01235 <span class="preprocessor"></span>          cout &lt;&lt; <span class="stringliteral">&quot;Tag[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] Histomin = &quot;</span> &lt;&lt; gpTAsettdc32.tag[i].Histominb
<a name="l01236"></a>01236                &lt;&lt; <span class="stringliteral">&quot; Histomax = &quot;</span> &lt;&lt; gpTAsettdc32.tag[i].Histomaxb &lt;&lt; endl;
<a name="l01237"></a>01237 <span class="preprocessor">#endif</span>
<a name="l01238"></a>01238 <span class="preprocessor"></span>          <span class="comment">// is a histogram there?</span>
<a name="l01239"></a>01239           <span class="keywordflow">if</span> ((nbins=(gpTAsettdc32.tag[i].Histomaxb-gpTAsettdc32.tag[i].Histominb + 1))
<a name="l01240"></a>01240                &gt;1)
<a name="l01241"></a>01241           {
<a name="l01242"></a>01242 
<a name="l01243"></a>01243             <span class="comment">// first histo -&gt; take histogram length</span>
<a name="l01244"></a>01244             <span class="keywordflow">if</span> (number_histo == 0)
<a name="l01245"></a>01245               length_histo = nbins+gpTAsettdc32.tag[i].Histominb;
<a name="l01246"></a>01246             <span class="comment">// different histogram length?</span>
<a name="l01247"></a>01247             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length_histo != nbins+gpTAsettdc32.tag[i].Histominb)
<a name="l01248"></a>01248             {
<a name="l01249"></a>01249               cout &lt;&lt; <span class="stringliteral">&quot;Different histogram lengths!&quot;</span> &lt;&lt; endl;
<a name="l01250"></a>01250             }
<a name="l01251"></a>01251             number_histo++;
<a name="l01252"></a>01252           }
<a name="l01253"></a>01253         }
<a name="l01254"></a>01254       }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256     }
<a name="l01257"></a>01257     <span class="keywordflow">else</span>
<a name="l01258"></a>01258     {
<a name="l01259"></a>01259       tothist = 0;
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262       <span class="comment">// no histograms to process?</span>
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (tothist &lt;= 0)
<a name="l01264"></a>01264     {
<a name="l01265"></a>01265       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l01266"></a>01266       file_name.close();
<a name="l01267"></a>01267       readstatus  = <span class="stringliteral">&quot;ERROR Less than 1 histogram in &quot;</span>  + filename ;
<a name="l01268"></a>01268       <span class="keywordflow">return</span> 5;                                <span class="comment">// ERROR number of histograms &lt; 1</span>
<a name="l01269"></a>01269     }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="keywordflow">if</span> (tothist &gt; MAXHISTO)
<a name="l01272"></a>01272     {
<a name="l01273"></a>01273       cout &lt;&lt; <span class="stringliteral">&quot;ERROR number of histograms &quot;</span> &lt;&lt; tothist &lt;&lt; <span class="stringliteral">&quot; exceedes maximum &quot;</span>
<a name="l01274"></a>01274            &lt;&lt; MAXHISTO &lt;&lt; <span class="stringliteral">&quot;! - Setting maximum number &quot;</span> &lt;&lt; endl;
<a name="l01275"></a>01275       tothist = MAXHISTO;
<a name="l01276"></a>01276     }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l01279"></a>01279 <span class="preprocessor"></span>  cout &lt;&lt; <span class="stringliteral">&quot;Number of histograms is &quot;</span> &lt;&lt; number_histo &lt;&lt; endl;
<a name="l01280"></a>01280   cout &lt;&lt; <span class="stringliteral">&quot;Histogram length is &quot;</span>     &lt;&lt; length_histo &lt;&lt; endl;
<a name="l01281"></a>01281   cout &lt;&lt; <span class="stringliteral">&quot;Resolutionfactor for t0, fg, lg is &quot;</span> &lt;&lt; resolutionfactor &lt;&lt; endl;
<a name="l01282"></a>01282 <span class="preprocessor">#endif</span>
<a name="l01283"></a>01283 <span class="preprocessor"></span>
<a name="l01284"></a>01284     default_binning = resolutionfactor;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="comment">// allocate histograms</span>
<a name="l01287"></a>01287     histo = <span class="keyword">new</span> <span class="keywordtype">int</span>* [int(number_histo)];
<a name="l01288"></a>01288     <span class="keywordflow">if</span> (!histo)
<a name="l01289"></a>01289     {
<a name="l01290"></a>01290       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l01291"></a>01291       file_name.close();
<a name="l01292"></a>01292       readstatus = <span class="stringliteral">&quot;ERROR Allocating histo failed!&quot;</span>;
<a name="l01293"></a>01293       <span class="keywordflow">return</span> 3;                                <span class="comment">// ERROR allocating histogram buffer</span>
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="keywordflow">for</span> (i=0; i&lt;number_histo; i++)
<a name="l01297"></a>01297     {
<a name="l01298"></a>01298       histo[i] = <span class="keyword">new</span> <span class="keywordtype">int</span> [length_histo];
<a name="l01299"></a>01299 
<a name="l01300"></a>01300       <span class="keywordflow">if</span> (!histo[i])
<a name="l01301"></a>01301       {
<a name="l01302"></a>01302         <span class="keywordflow">for</span> (j=0; j&lt;i; j++)
<a name="l01303"></a>01303           <span class="keyword">delete</span> histo[j];
<a name="l01304"></a>01304         <span class="keyword">delete</span> [] histo;
<a name="l01305"></a>01305         histo = NULL;
<a name="l01306"></a>01306         <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l01307"></a>01307         file_name.close();
<a name="l01308"></a>01308         readstatus = <span class="stringliteral">&quot;ERROR Allocating histo[] failed!&quot;</span>;
<a name="l01309"></a>01309         <span class="keywordflow">return</span> 3;                                <span class="comment">// ERROR allocating histogram buffer</span>
<a name="l01310"></a>01310       }
<a name="l01311"></a>01311     }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313     pTATagRec tag;
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     total_events   = 0;
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="keywordflow">for</span> (i=0; i&lt;number_histo; i++)
<a name="l01318"></a>01318       events_per_histo[i] = 0;
<a name="l01319"></a>01319 
<a name="l01320"></a>01320     <span class="keywordtype">int</span> ihist = 0;
<a name="l01321"></a>01321     Int32 *thist = NULL;
<a name="l01322"></a>01322     vector&lt;double&gt; dummy_vector ;
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>.clear();
<a name="l01325"></a>01325     <span class="keywordflow">for</span> (i=0,ihist=0; i&lt; tothist; i++)
<a name="l01326"></a>01326     {
<a name="l01327"></a>01327       file_name.read((<span class="keywordtype">char</span> *)&amp;tag, <span class="keyword">sizeof</span> tag) ; <span class="comment">// read tag into buffer</span>
<a name="l01328"></a>01328       <span class="keywordflow">if</span> (file_name.fail())
<a name="l01329"></a>01329       {
<a name="l01330"></a>01330         dummy_vector.clear() ;
<a name="l01331"></a>01331         <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l01332"></a>01332         <span class="keywordflow">if</span> (thist != NULL) <span class="keyword">delete</span> [] thist; thist = NULL;
<a name="l01333"></a>01333         file_name.close();
<a name="l01334"></a>01334         readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; tag failed!&quot;</span>;
<a name="l01335"></a>01335         <span class="keywordflow">return</span> 6;                                  <span class="comment">// ERROR reading tag failed</span>
<a name="l01336"></a>01336       }
<a name="l01337"></a>01337                   <span class="comment">/* read histogram data */</span>
<a name="l01338"></a>01338         <span class="keywordflow">if</span> (tag.Type == PTATAGC_POSITRON)
<a name="l01339"></a>01339         {
<a name="l01340"></a>01340           <span class="keywordtype">int</span> nbins;
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 <span class="preprocessor">#ifdef MIDEBUG1</span>
<a name="l01343"></a>01343 <span class="preprocessor"></span>          cout &lt;&lt; <span class="stringliteral">&quot;Tag[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; tag.Label &lt;&lt; <span class="stringliteral">&quot; : Histomin = &quot;</span> &lt;&lt; tag.Histominb
<a name="l01344"></a>01344                &lt;&lt; <span class="stringliteral">&quot; Histomax = &quot;</span> &lt;&lt; tag.Histomaxb &lt;&lt; endl;
<a name="l01345"></a>01345 <span class="preprocessor">#endif</span>
<a name="l01346"></a>01346 <span class="preprocessor"></span>          <span class="comment">// is a histogram there?</span>
<a name="l01347"></a>01347           <span class="keywordflow">if</span> ((nbins=(tag.Histomaxb-tag.Histominb + 1))&gt;1)
<a name="l01348"></a>01348           {
<a name="l01349"></a>01349             <span class="keywordflow">if</span> (thist == NULL) thist = <span class="keyword">new</span> Int32[nbins];
<a name="l01350"></a>01350             <span class="keywordflow">if</span> (thist == NULL)
<a name="l01351"></a>01351             {
<a name="l01352"></a>01352               <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l01353"></a>01353               file_name.close();
<a name="l01354"></a>01354               readstatus = <span class="stringliteral">&quot;ERROR Allocating histogram buffer failed!&quot;</span>;
<a name="l01355"></a>01355               <span class="keywordflow">return</span> 3;                                <span class="comment">// ERROR allocating histogram buffer</span>
<a name="l01356"></a>01356             }
<a name="l01357"></a>01357 
<a name="l01358"></a>01358             file_name.read((<span class="keywordtype">char</span> *)thist, <span class="keyword">sizeof</span>(Int32)*nbins) ;<span class="comment">// read hist into buffer</span>
<a name="l01359"></a>01359             <span class="keywordflow">if</span> (file_name.fail())
<a name="l01360"></a>01360             {
<a name="l01361"></a>01361               <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">Clear</a>();
<a name="l01362"></a>01362               <span class="keywordflow">if</span> (thist != NULL) <span class="keyword">delete</span> [] thist; thist = NULL;
<a name="l01363"></a>01363               file_name.close();
<a name="l01364"></a>01364               readstatus  = <span class="stringliteral">&quot;ERROR Reading &quot;</span>+filename+<span class="stringliteral">&quot; hist failed!&quot;</span>;
<a name="l01365"></a>01365               <span class="keywordflow">return</span> 6;                                  <span class="comment">// ERROR reading hist failed</span>
<a name="l01366"></a>01366             }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368             <span class="comment">// for pTA only: use histogram only, if histogram was selected</span>
<a name="l01369"></a>01369             <span class="comment">// else take all histos but mark not selected</span>
<a name="l01370"></a>01370             <span class="keywordflow">if</span> (selected[i] || (strcmp(format_id,<span class="stringliteral">&quot;M3&quot;</span>) != 0))
<a name="l01371"></a>01371             {
<a name="l01372"></a>01372 
<a name="l01373"></a>01373               <span class="keywordflow">if</span> (ihist &lt; MAXHISTO) <span class="comment">// max number of histos not yet reached?</span>
<a name="l01374"></a>01374               {
<a name="l01375"></a>01375                 dummy_vector.clear() ;
<a name="l01376"></a>01376 
<a name="l01377"></a>01377                 strncpy(labels_histo[ihist],tag.Label,MAXLABELSIZE) ;
<a name="l01378"></a>01378                 labels_histo[ihist][MAXLABELSIZE-1] = <span class="charliteral">&apos;\0&apos;</span> ;
<a name="l01379"></a>01379 
<a name="l01380"></a>01380                 <span class="comment">// mark with ** when not selected</span>
<a name="l01381"></a>01381                 <span class="keywordflow">if</span> (!selected[i] &amp;&amp; (strlen(labels_histo[ihist])&lt;MAXLABELSIZE-2))
<a name="l01382"></a>01382                   strcat(labels_histo[ihist],<span class="stringliteral">&quot;**&quot;</span>);
<a name="l01383"></a>01383 
<a name="l01384"></a>01384                 <span class="comment">// calculate t0, fg, lg for &quot;raw&quot; TDC /pTA actually specified for binned</span>
<a name="l01385"></a>01385                 <span class="comment">// histograms </span>
<a name="l01386"></a>01386                 <span class="comment">// taking largest possible bin value for t0 and fg</span>
<a name="l01387"></a>01387                 integer_t0[ihist] = (tag.t0b+1)*resolutionfactor -1;
<a name="l01388"></a>01388                 first_good[ihist] = (tag.tfb+1)*resolutionfactor -1;
<a name="l01389"></a>01389                 last_good[ihist]  =  tag.tlb*resolutionfactor ;
<a name="l01390"></a>01390 
<a name="l01391"></a>01391                 <span class="comment">// store histogram</span>
<a name="l01392"></a>01392                 <span class="comment">// in case of non zero offset init</span>
<a name="l01393"></a>01393                 <span class="keywordflow">for</span> (j=0; j&lt;tag.Histominb; j++)
<a name="l01394"></a>01394                 {
<a name="l01395"></a>01395                   histo[ihist][j]= 0;
<a name="l01396"></a>01396                   dummy_vector.push_back(<span class="keywordtype">double</span>(histo[ihist][j])) ;
<a name="l01397"></a>01397                 }
<a name="l01398"></a>01398                 <span class="comment">// fill histogram</span>
<a name="l01399"></a>01399                 <span class="keywordflow">for</span> (j=tag.Histominb; j&lt;length_histo; j++)
<a name="l01400"></a>01400                 {
<a name="l01401"></a>01401                   histo[ihist][j]= *(thist+j-tag.Histominb);
<a name="l01402"></a>01402                   dummy_vector.push_back(<span class="keywordtype">double</span>(histo[ihist][j])) ;
<a name="l01403"></a>01403 
<a name="l01404"></a>01404                   <span class="comment">// do summation of events between fg and lg</span>
<a name="l01405"></a>01405                   <span class="keywordflow">if</span> ((j &gt;= first_good[ihist]) &amp;&amp; (j &lt;= last_good[ihist]))
<a name="l01406"></a>01406                     events_per_histo[ihist] += *(thist+j-tag.Histominb);
<a name="l01407"></a>01407                 }
<a name="l01408"></a>01408                 <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>.push_back(dummy_vector) ;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410                 <span class="comment">// only add selected histo(s) to total events</span>
<a name="l01411"></a>01411                 <span class="keywordflow">if</span> (selected[i])
<a name="l01412"></a>01412                   total_events += events_per_histo[ihist];
<a name="l01413"></a>01413               }
<a name="l01414"></a>01414               ihist++;
<a name="l01415"></a>01415             }
<a name="l01416"></a>01416           }
<a name="l01417"></a>01417         }
<a name="l01418"></a>01418     }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420     <span class="keywordflow">if</span> (thist != NULL) <span class="keyword">delete</span> [] thist; thist = NULL;
<a name="l01421"></a>01421 
<a name="l01422"></a>01422     file_name.close();
<a name="l01423"></a>01423 
<a name="l01424"></a>01424     readstatus = <span class="stringliteral">&quot;SUCCESS&quot;</span>;
<a name="l01425"></a>01425     readingok = <span class="keyword">true</span>;
<a name="l01426"></a>01426 
<a name="l01427"></a>01427     <span class="keywordflow">return</span> 0;
<a name="l01428"></a>01428   }
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="comment">//*******************************</span>
<a name="l01431"></a>01431 <span class="comment">//Implementation readingOK</span>
<a name="l01432"></a>01432 <span class="comment">//*******************************</span>
<a name="l01433"></a>01433 
<a name="l01440"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afaeabd42e75d8569470d74cff0a9be98">01440</a> <span class="keywordtype">bool</span>           <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afaeabd42e75d8569470d74cff0a9be98" title="Method to obtain if reading and processing of the data file was OK.">MuSR_td_PSI_bin::readingOK</a>()<span class="keyword"> const </span>{
<a name="l01441"></a>01441    <span class="keywordflow">return</span> readingok;
<a name="l01442"></a>01442 }
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 <span class="comment">//*******************************</span>
<a name="l01445"></a>01445 <span class="comment">//Implementation ReadStatus</span>
<a name="l01446"></a>01446 <span class="comment">//*******************************</span>
<a name="l01447"></a>01447 
<a name="l01454"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a95ed36c8b4df9516d54514142ea90e7b">01454</a> <span class="keywordtype">string</span>         <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a95ed36c8b4df9516d54514142ea90e7b" title="Method to obtain error/success information after reading.">MuSR_td_PSI_bin::ReadStatus</a>()<span class="keyword"> const </span>{
<a name="l01455"></a>01455    <span class="keywordflow">return</span> readstatus;
<a name="l01456"></a>01456 }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458 <span class="comment">//*******************************</span>
<a name="l01459"></a>01459 <span class="comment">//Implementation Filename</span>
<a name="l01460"></a>01460 <span class="comment">//*******************************</span>
<a name="l01461"></a>01461 
<a name="l01467"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac63ae3167f618ac3bc8526cf8eff5cdd">01467</a> <span class="keywordtype">string</span>         <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac63ae3167f618ac3bc8526cf8eff5cdd" title="Method to obtain the file name.">MuSR_td_PSI_bin::Filename</a>()<span class="keyword"> const </span>{
<a name="l01468"></a>01468    <span class="keywordflow">return</span> filename;
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="comment">//*******************************</span>
<a name="l01472"></a>01472 <span class="comment">//Implementation get_histo_int</span>
<a name="l01473"></a>01473 <span class="comment">//*******************************</span>
<a name="l01474"></a>01474 
<a name="l01481"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#af51b46a879d27358afde8dc0380eaace">01481</a> <span class="keywordtype">int</span>     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#af51b46a879d27358afde8dc0380eaace" title="Method to return the value of a single bin as integer.">MuSR_td_PSI_bin::get_histo_int</a>(<span class="keywordtype">int</span> histo_num, <span class="keywordtype">int</span> j) {
<a name="l01482"></a>01482     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> 0;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484     <span class="keywordflow">if</span> (( histo_num &lt; 0) || (histo_num &gt;= <span class="keywordtype">int</span>(number_histo)) ||
<a name="l01485"></a>01485        (j &lt; 0 ) || (j &gt;= length_histo))
<a name="l01486"></a>01486       <span class="keywordflow">return</span> 0 ;
<a name="l01487"></a>01487 <span class="preprocessor">#ifdef MIDEBUG</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;histos_vector[0][0] = &quot;</span> &lt;&lt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>[0][0] &lt;&lt; endl;
<a name="l01489"></a>01489 <span class="preprocessor">#endif</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span>    <span class="keywordflow">return</span> histo[histo_num][j];
<a name="l01491"></a>01491 }
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="comment">//*******************************</span>
<a name="l01494"></a>01494 <span class="comment">//Implementation get_histo</span>
<a name="l01495"></a>01495 <span class="comment">//*******************************</span>
<a name="l01496"></a>01496 
<a name="l01503"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a6d2dcc7f5ee73f9a5944d3f698678638">01503</a> <span class="keywordtype">double</span>  <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a6d2dcc7f5ee73f9a5944d3f698678638" title="Method to return the value of a single bin as double.">MuSR_td_PSI_bin::get_histo</a>(<span class="keywordtype">int</span> histo_num, <span class="keywordtype">int</span> j) {
<a name="l01504"></a>01504     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> 0.;
<a name="l01505"></a>01505 
<a name="l01506"></a>01506     <span class="keywordflow">if</span> (( histo_num &lt; 0) || (histo_num &gt;= <span class="keywordtype">int</span>(number_histo)) ||
<a name="l01507"></a>01507        (j &lt; 0 ) || (j &gt;= length_histo))
<a name="l01508"></a>01508       <span class="keywordflow">return</span> 0. ;
<a name="l01509"></a>01509 <span class="preprocessor">#ifdef MIDEBUG</span>
<a name="l01510"></a>01510 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;histos_vector[0][0] = &quot;</span> &lt;&lt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>[0][0] &lt;&lt; endl;
<a name="l01511"></a>01511 <span class="preprocessor">#endif</span>
<a name="l01512"></a>01512 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)histo[histo_num][j];
<a name="l01513"></a>01513 }
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 <span class="comment">//*******************************</span>
<a name="l01516"></a>01516 <span class="comment">//Implementation get_histo_array</span>
<a name="l01517"></a>01517 <span class="comment">//*******************************</span>
<a name="l01518"></a>01518 
<a name="l01531"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aaa11f000e414b03a7fb4ff7714687159">01531</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aaa11f000e414b03a7fb4ff7714687159" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_array</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning)
<a name="l01532"></a>01532   {
<a name="l01533"></a>01533     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l01534"></a>01534 
<a name="l01535"></a>01535     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01536"></a>01536       <span class="keywordflow">return</span> NULL ;
<a name="l01537"></a>01537 
<a name="l01538"></a>01538     <span class="keywordtype">double</span> *histo_array = <span class="keyword">new</span> <span class="keywordtype">double</span>[int(<span class="keywordtype">int</span>(length_histo)/binning)] ;
<a name="l01539"></a>01539 
<a name="l01540"></a>01540     <span class="keywordflow">if</span> (!histo_array) <span class="keywordflow">return</span> NULL;
<a name="l01541"></a>01541 
<a name="l01542"></a>01542     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(<span class="keywordtype">int</span>(length_histo)/binning) ; i++)
<a name="l01543"></a>01543     {
<a name="l01544"></a>01544       histo_array[i] = 0 ;
<a name="l01545"></a>01545       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01546"></a>01546       histo_array[i] += <span class="keywordtype">double</span>(histo[histo_num][i*binning+j]) ;
<a name="l01547"></a>01547     }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     <span class="keywordflow">return</span> histo_array ;
<a name="l01550"></a>01550   }
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="comment">//*******************************</span>
<a name="l01554"></a>01554 <span class="comment">//Implementation get_histo_vector</span>
<a name="l01555"></a>01555 <span class="comment">//*******************************</span>
<a name="l01556"></a>01556 
<a name="l01568"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a270daf17990e43d3713c0c3f6bd6940a">01568</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a270daf17990e43d3713c0c3f6bd6940a" title="Method to obtain a vector of double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_vector</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning)
<a name="l01569"></a>01569   {
<a name="l01570"></a>01570     vector&lt;double&gt; histo_vector ; <span class="comment">//(int(length_histo/binning))</span>
<a name="l01571"></a>01571 
<a name="l01572"></a>01572     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> histo_vector;
<a name="l01573"></a>01573 
<a name="l01574"></a>01574     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01575"></a>01575       <span class="keywordflow">return</span> histo_vector ;
<a name="l01576"></a>01576 
<a name="l01577"></a>01577     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(length_histo/binning) ; i++)
<a name="l01578"></a>01578       histo_vector.push_back(0.) ;
<a name="l01579"></a>01579 
<a name="l01580"></a>01580     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(length_histo/binning) ; i++)
<a name="l01581"></a>01581     {
<a name="l01582"></a>01582       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01583"></a>01583       histo_vector[i] += <span class="keywordtype">double</span>(histo[histo_num][i*binning+j]) ;
<a name="l01584"></a>01584     }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     <span class="keywordflow">return</span> histo_vector ;
<a name="l01587"></a>01587   }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 
<a name="l01590"></a>01590 <span class="comment">//*******************************</span>
<a name="l01591"></a>01591 <span class="comment">//Implementation get_histo_vector_no0</span>
<a name="l01592"></a>01592 <span class="comment">//*******************************</span>
<a name="l01593"></a>01593 
<a name="l01606"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aeacd731b1290e087ad65070924e30dbc">01606</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aeacd731b1290e087ad65070924e30dbc" title="Method to obtain a vector of double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_vector_no0</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning)
<a name="l01607"></a>01607   {
<a name="l01608"></a>01608     vector&lt;double&gt; histo_vector; <span class="comment">//(int(length_histo/binning)) ;</span>
<a name="l01609"></a>01609 
<a name="l01610"></a>01610     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> histo_vector;
<a name="l01611"></a>01611 
<a name="l01612"></a>01612     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01613"></a>01613       <span class="keywordflow">return</span> histo_vector ;
<a name="l01614"></a>01614 
<a name="l01615"></a>01615     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(length_histo/binning) ; i++)
<a name="l01616"></a>01616       histo_vector.push_back(0.) ;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(length_histo/binning) ; i++)
<a name="l01619"></a>01619     {
<a name="l01620"></a>01620       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01621"></a>01621       histo_vector[i] += <span class="keywordtype">double</span>(histo[histo_num][i*binning+j]) ;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623       <span class="keywordflow">if</span> (histo_vector[i] &lt; 0.5 )
<a name="l01624"></a>01624       {
<a name="l01625"></a>01625         histo_vector[i] = 0.1 ;
<a name="l01626"></a>01626       }
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     <span class="keywordflow">return</span> histo_vector ;
<a name="l01630"></a>01630   }
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 
<a name="l01633"></a>01633 <span class="comment">//**********************************</span>
<a name="l01634"></a>01634 <span class="comment">//Implementation get_histo_array_int</span>
<a name="l01635"></a>01635 <span class="comment">//**********************************</span>
<a name="l01636"></a>01636 
<a name="l01648"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a67eae9cd710a0c8bb797b32cc16e1366">01648</a>   <span class="keywordtype">int</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a67eae9cd710a0c8bb797b32cc16e1366" title="Method to obtain an array of type integer containing the values of the histogram...">MuSR_td_PSI_bin::get_histo_array_int</a>(<span class="keywordtype">int</span> histo_num)
<a name="l01649"></a>01649   {
<a name="l01650"></a>01650     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l01651"></a>01651 
<a name="l01652"></a>01652     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l01653"></a>01653        <span class="keywordflow">return</span> NULL ;
<a name="l01654"></a>01654 
<a name="l01655"></a>01655     <span class="keywordtype">int</span> *histo_array = <span class="keyword">new</span> <span class="keywordtype">int</span>[length_histo] ;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657     <span class="keywordflow">if</span> (!histo_array) <span class="keywordflow">return</span> NULL;
<a name="l01658"></a>01658 
<a name="l01659"></a>01659     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(length_histo) ; i++)
<a name="l01660"></a>01660     {
<a name="l01661"></a>01661       histo_array[i] = int(histo[histo_num][i]) ;
<a name="l01662"></a>01662     }
<a name="l01663"></a>01663 
<a name="l01664"></a>01664     <span class="keywordflow">return</span> histo_array ;
<a name="l01665"></a>01665   }
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 <span class="comment">//*******************************</span>
<a name="l01669"></a>01669 <span class="comment">//Implementation get_histo_fromt0_array</span>
<a name="l01670"></a>01670 <span class="comment">//*******************************</span>
<a name="l01671"></a>01671 
<a name="l01685"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a0b16d393aaeed3a8cc20539b5794daa5">01685</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a0b16d393aaeed3a8cc20539b5794daa5" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_fromt0_array</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> offset)
<a name="l01686"></a>01686   {
<a name="l01687"></a>01687     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01690"></a>01690       <span class="keywordflow">return</span> NULL ;
<a name="l01691"></a>01691 
<a name="l01692"></a>01692     <span class="keywordtype">double</span> *histo_fromt0_array = 
<a name="l01693"></a>01693       <span class="keyword">new</span> <span class="keywordtype">double</span>[int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset+1)/binning)] ;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695     <span class="keywordflow">if</span> (!histo_fromt0_array) <span class="keywordflow">return</span> NULL;
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset)/binning) ; i++)
<a name="l01698"></a>01698     {
<a name="l01699"></a>01699       histo_fromt0_array[i] = 0 ;
<a name="l01700"></a>01700       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01701"></a>01701       histo_fromt0_array[i] += 
<a name="l01702"></a>01702         <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)+offset]) ;
<a name="l01703"></a>01703     }
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="keywordflow">return</span> histo_fromt0_array ;
<a name="l01706"></a>01706   }
<a name="l01707"></a>01707 
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="comment">//*******************************</span>
<a name="l01710"></a>01710 <span class="comment">//Implementation get_histo_fromt0_vector</span>
<a name="l01711"></a>01711 <span class="comment">//*******************************</span>
<a name="l01712"></a>01712 
<a name="l01725"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4d5312751492d94de452efb97a33f74f">01725</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4d5312751492d94de452efb97a33f74f" title="Method to obtain a vector of double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_fromt0_vector</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> offset)
<a name="l01726"></a>01726   {
<a name="l01727"></a>01727     vector&lt;double&gt; histo_fromt0_vector ; <span class="comment">// (int((int(length_histo)-get_t0_int(histo_num)+1)/binning)) ;</span>
<a name="l01728"></a>01728 
<a name="l01729"></a>01729     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> histo_fromt0_vector;
<a name="l01730"></a>01730 
<a name="l01731"></a>01731     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01732"></a>01732       <span class="keywordflow">return</span> histo_fromt0_vector ;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset)/binning) ; i++)
<a name="l01735"></a>01735       histo_fromt0_vector.push_back(0.) ;
<a name="l01736"></a>01736 
<a name="l01737"></a>01737     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset)/binning) ; i++)
<a name="l01738"></a>01738     {
<a name="l01739"></a>01739       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01740"></a>01740       histo_fromt0_vector[i] += 
<a name="l01741"></a>01741         <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)+offset]) ;
<a name="l01742"></a>01742     }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744     <span class="keywordflow">return</span> histo_fromt0_vector ;
<a name="l01745"></a>01745   }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 
<a name="l01748"></a>01748 <span class="comment">//*******************************</span>
<a name="l01749"></a>01749 <span class="comment">//Implementation get_histo_goodBins_array</span>
<a name="l01750"></a>01750 <span class="comment">//*******************************</span>
<a name="l01751"></a>01751 
<a name="l01764"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a5c8f2f7fe48409100ae8dde206623d34">01764</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a5c8f2f7fe48409100ae8dde206623d34" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_goodBins_array</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning)
<a name="l01765"></a>01765   {
<a name="l01766"></a>01766     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l01767"></a>01767     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01768"></a>01768       <span class="keywordflow">return</span> NULL ;
<a name="l01769"></a>01769 
<a name="l01770"></a>01770     <span class="keywordtype">double</span> *histo_goodBins_array = 
<a name="l01771"></a>01771       <span class="keyword">new</span> <span class="keywordtype">double</span>[int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num)+1)/binning)] ;
<a name="l01772"></a>01772 
<a name="l01773"></a>01773     <span class="keywordflow">if</span> (!histo_goodBins_array) <span class="keywordflow">return</span> NULL;
<a name="l01774"></a>01774 
<a name="l01775"></a>01775     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num))/binning) ; i++)
<a name="l01776"></a>01776     {
<a name="l01777"></a>01777       histo_goodBins_array[i] = 0 ;
<a name="l01778"></a>01778       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01779"></a>01779       histo_goodBins_array[i] += 
<a name="l01780"></a>01780         <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num)]) ;
<a name="l01781"></a>01781     }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783     <span class="keywordflow">return</span> histo_goodBins_array ;
<a name="l01784"></a>01784   }
<a name="l01785"></a>01785 
<a name="l01786"></a>01786 
<a name="l01787"></a>01787 <span class="comment">//*******************************</span>
<a name="l01788"></a>01788 <span class="comment">//Implementation get_histo_goodBins_vector</span>
<a name="l01789"></a>01789 <span class="comment">//*******************************</span>
<a name="l01790"></a>01790 
<a name="l01803"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a6dce48fc83a9b9b40ae9b12bf2b819dc">01803</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a6dce48fc83a9b9b40ae9b12bf2b819dc" title="Method to obtain a vector of double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_goodBins_vector</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> binning)
<a name="l01804"></a>01804   {
<a name="l01805"></a>01805     vector&lt;double&gt; histo_goodBins_vector ;
<a name="l01806"></a>01806 
<a name="l01807"></a>01807     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> histo_goodBins_vector;
<a name="l01808"></a>01808 
<a name="l01809"></a>01809     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01810"></a>01810       <span class="keywordflow">return</span> histo_goodBins_vector ;
<a name="l01811"></a>01811 
<a name="l01812"></a>01812     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num))/binning) ; i++)
<a name="l01813"></a>01813       histo_goodBins_vector.push_back(0.) ;
<a name="l01814"></a>01814 
<a name="l01815"></a>01815     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num))/binning) ; i++)
<a name="l01816"></a>01816     {
<a name="l01817"></a>01817       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01818"></a>01818       histo_goodBins_vector[i] += 
<a name="l01819"></a>01819         <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num)]) ;
<a name="l01820"></a>01820     }
<a name="l01821"></a>01821 
<a name="l01822"></a>01822     <span class="keywordflow">return</span> histo_goodBins_vector ;
<a name="l01823"></a>01823   }
<a name="l01824"></a>01824 
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 <span class="comment">//*******************************</span>
<a name="l01827"></a>01827 <span class="comment">//Implementation get_histo_fromt0_minus_bckgrd_array</span>
<a name="l01828"></a>01828 <span class="comment">//*******************************</span>
<a name="l01829"></a>01829 
<a name="l01849"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b">01849</a> <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_fromt0_minus_bckgrd_array</a>(<span class="keywordtype">int</span> histo_num , 
<a name="l01850"></a>01850                        <span class="keywordtype">int</span> lower_bckgrd , <span class="keywordtype">int</span> higher_bckgrd , <span class="keywordtype">int</span> binning, <span class="keywordtype">int</span> offset)
<a name="l01851"></a>01851   {
<a name="l01852"></a>01852     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l01853"></a>01853 
<a name="l01854"></a>01854     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01855"></a>01855       <span class="keywordflow">return</span> NULL ;
<a name="l01856"></a>01856 
<a name="l01857"></a>01857     <span class="keywordflow">if</span> ( lower_bckgrd &lt; 0 || higher_bckgrd &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd &gt; higher_bckgrd )
<a name="l01858"></a>01858       <span class="keywordflow">return</span> NULL ;
<a name="l01859"></a>01859 
<a name="l01860"></a>01860     <span class="keywordtype">double</span> bckgrd = 0 ;
<a name="l01861"></a>01861 
<a name="l01862"></a>01862     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = lower_bckgrd ; k &lt;= higher_bckgrd ; k++)
<a name="l01863"></a>01863     {
<a name="l01864"></a>01864       bckgrd += double(histo[histo_num][k]) ;
<a name="l01865"></a>01865     }
<a name="l01866"></a>01866     bckgrd = bckgrd/(higher_bckgrd-lower_bckgrd+1) ;
<a name="l01867"></a>01867 
<a name="l01868"></a>01868     <span class="keywordtype">double</span> *histo_fromt0_minus_bckgrd_array = 
<a name="l01869"></a>01869       <span class="keyword">new</span> <span class="keywordtype">double</span>[int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset+1)/binning)] ;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871     <span class="keywordflow">if</span> (!histo_fromt0_minus_bckgrd_array) <span class="keywordflow">return</span> NULL;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset)/binning) ; i++)
<a name="l01874"></a>01874     {
<a name="l01875"></a>01875       histo_fromt0_minus_bckgrd_array[i] = 0 ;
<a name="l01876"></a>01876       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01877"></a>01877         histo_fromt0_minus_bckgrd_array[i] +=
<a name="l01878"></a>01878           <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)+offset]) - bckgrd;
<a name="l01879"></a>01879     }
<a name="l01880"></a>01880 
<a name="l01881"></a>01881     <span class="keywordflow">return</span> histo_fromt0_minus_bckgrd_array ;
<a name="l01882"></a>01882   } ;
<a name="l01883"></a>01883 
<a name="l01884"></a>01884 <span class="comment">//*******************************</span>
<a name="l01885"></a>01885 <span class="comment">//Implementation get_histo_fromt0_minus_bckgrd_vector</span>
<a name="l01886"></a>01886 <span class="comment">//*******************************</span>
<a name="l01887"></a>01887  
<a name="l01906"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a9593a99a3d9293bb02ed57bb040a592a">01906</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a9593a99a3d9293bb02ed57bb040a592a" title="Method to obtain a vector of double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_fromt0_minus_bckgrd_vector</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> lower_bckgrd ,
<a name="l01907"></a>01907                                                                          <span class="keywordtype">int</span> higher_bckgrd , <span class="keywordtype">int</span> binning, <span class="keywordtype">int</span> offset)
<a name="l01908"></a>01908   {
<a name="l01909"></a>01909     vector&lt;double&gt; histo_fromt0_minus_bckgrd_vector ; <span class="comment">// (int((int(length_histo)-get_t0_int(histo_num)+1)/binning)) ;</span>
<a name="l01910"></a>01910 
<a name="l01911"></a>01911     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> histo_fromt0_minus_bckgrd_vector;
<a name="l01912"></a>01912 
<a name="l01913"></a>01913     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01914"></a>01914       <span class="keywordflow">return</span> histo_fromt0_minus_bckgrd_vector ;
<a name="l01915"></a>01915 
<a name="l01916"></a>01916     <span class="keywordflow">if</span> ( lower_bckgrd &lt; 0 || higher_bckgrd &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd &gt; higher_bckgrd )
<a name="l01917"></a>01917       <span class="keywordflow">return</span> histo_fromt0_minus_bckgrd_vector ;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919     <span class="keywordtype">double</span> bckgrd = 0 ;
<a name="l01920"></a>01920     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = lower_bckgrd ; k &lt;= higher_bckgrd ; k++)
<a name="l01921"></a>01921     {
<a name="l01922"></a>01922        bckgrd += double(histo[histo_num][k]) ;
<a name="l01923"></a>01923     }
<a name="l01924"></a>01924     bckgrd = bckgrd/(higher_bckgrd-lower_bckgrd+1) ;
<a name="l01925"></a>01925 
<a name="l01926"></a>01926     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset)/binning) ; i++)
<a name="l01927"></a>01927       histo_fromt0_minus_bckgrd_vector.push_back(0.) ;
<a name="l01928"></a>01928 
<a name="l01929"></a>01929     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)-offset)/binning) ; i++)
<a name="l01930"></a>01930     {
<a name="l01931"></a>01931       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01932"></a>01932         histo_fromt0_minus_bckgrd_vector[i] +=
<a name="l01933"></a>01933         <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num)+offset]) - bckgrd;
<a name="l01934"></a>01934     }
<a name="l01935"></a>01935 
<a name="l01936"></a>01936     <span class="keywordflow">return</span> histo_fromt0_minus_bckgrd_vector ;
<a name="l01937"></a>01937   }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="comment">//*******************************</span>
<a name="l01941"></a>01941 <span class="comment">//Implementation get_histo_goodBins_minus_bckgrd_array</span>
<a name="l01942"></a>01942 <span class="comment">//*******************************</span>
<a name="l01943"></a>01943 
<a name="l01963"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4fe20f8cd8ec7a04dfafbe7f95ff4201">01963</a> <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4fe20f8cd8ec7a04dfafbe7f95ff4201" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_goodBins_minus_bckgrd_array</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> lower_bckgrd ,
<a name="l01964"></a>01964                                                                    <span class="keywordtype">int</span> higher_bckgrd , <span class="keywordtype">int</span> binning)
<a name="l01965"></a>01965   {
<a name="l01966"></a>01966     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l01967"></a>01967 
<a name="l01968"></a>01968     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l01969"></a>01969       <span class="keywordflow">return</span> NULL ;
<a name="l01970"></a>01970 
<a name="l01971"></a>01971     <span class="keywordflow">if</span> ( lower_bckgrd &lt; 0 || higher_bckgrd &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd &gt; higher_bckgrd )
<a name="l01972"></a>01972       <span class="keywordflow">return</span> NULL ;
<a name="l01973"></a>01973 
<a name="l01974"></a>01974     <span class="keywordtype">double</span> bckgrd = 0 ;
<a name="l01975"></a>01975     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = lower_bckgrd ; k &lt;= higher_bckgrd ; k++)
<a name="l01976"></a>01976     {
<a name="l01977"></a>01977       bckgrd += double(histo[histo_num][k]) ;
<a name="l01978"></a>01978     }
<a name="l01979"></a>01979     bckgrd = bckgrd/(higher_bckgrd-lower_bckgrd+1) ;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     <span class="keywordtype">double</span> *histo_goodBins_minus_bckgrd_array = 
<a name="l01982"></a>01982       <span class="keyword">new</span> <span class="keywordtype">double</span>[int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num)+1)/binning)] ;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984     <span class="keywordflow">if</span> (!histo_goodBins_minus_bckgrd_array) <span class="keywordflow">return</span> NULL;
<a name="l01985"></a>01985 
<a name="l01986"></a>01986     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num))/binning) ; i++)
<a name="l01987"></a>01987     {
<a name="l01988"></a>01988       histo_goodBins_minus_bckgrd_array[i] = 0 ;
<a name="l01989"></a>01989       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l01990"></a>01990         histo_goodBins_minus_bckgrd_array[i] +=
<a name="l01991"></a>01991           <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num)]) - bckgrd;
<a name="l01992"></a>01992     }
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     <span class="keywordflow">return</span> histo_goodBins_minus_bckgrd_array ;
<a name="l01995"></a>01995   } ;
<a name="l01996"></a>01996 
<a name="l01997"></a>01997 
<a name="l01998"></a>01998 <span class="comment">//*******************************</span>
<a name="l01999"></a>01999 <span class="comment">//Implementation get_histo_goodBins_minus_bckgrd_vector</span>
<a name="l02000"></a>02000 <span class="comment">//*******************************</span>
<a name="l02001"></a>02001 
<a name="l02020"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a99d1e501e90eac5f8b5dd39a0ff94988">02020</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a99d1e501e90eac5f8b5dd39a0ff94988" title="Method to obtain a vector of double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">MuSR_td_PSI_bin::get_histo_goodBins_minus_bckgrd_vector</a>(<span class="keywordtype">int</span> histo_num , <span class="keywordtype">int</span> lower_bckgrd ,
<a name="l02021"></a>02021                                                                            <span class="keywordtype">int</span> higher_bckgrd , <span class="keywordtype">int</span> binning)
<a name="l02022"></a>02022   {
<a name="l02023"></a>02023     vector&lt;double&gt; histo_goodBins_minus_bckgrd_vector ;  ;
<a name="l02024"></a>02024 
<a name="l02025"></a>02025     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> histo_goodBins_minus_bckgrd_vector;
<a name="l02026"></a>02026 
<a name="l02027"></a>02027     <span class="keywordflow">if</span> ( histo_num &lt; 0 || histo_num &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02028"></a>02028       <span class="keywordflow">return</span> histo_goodBins_minus_bckgrd_vector ;
<a name="l02029"></a>02029 
<a name="l02030"></a>02030     <span class="keywordflow">if</span> ( lower_bckgrd &lt; 0 || higher_bckgrd &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd &gt; higher_bckgrd )
<a name="l02031"></a>02031       <span class="keywordflow">return</span> histo_goodBins_minus_bckgrd_vector ;
<a name="l02032"></a>02032 
<a name="l02033"></a>02033     <span class="keywordtype">double</span> bckgrd = 0 ;
<a name="l02034"></a>02034     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = lower_bckgrd ; k &lt;= higher_bckgrd ; k++)
<a name="l02035"></a>02035     {
<a name="l02036"></a>02036       bckgrd += double(histo[histo_num][k]) ;
<a name="l02037"></a>02037     }
<a name="l02038"></a>02038     bckgrd = bckgrd/(higher_bckgrd-lower_bckgrd+1) ;
<a name="l02039"></a>02039 
<a name="l02040"></a>02040     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num))/binning) ; i++)
<a name="l02041"></a>02041       histo_goodBins_minus_bckgrd_vector.push_back(0.) ;
<a name="l02042"></a>02042 
<a name="l02043"></a>02043     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num))/binning) ; i++)
<a name="l02044"></a>02044     {
<a name="l02045"></a>02045       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; binning ; j++)
<a name="l02046"></a>02046         histo_goodBins_minus_bckgrd_vector[i] +=
<a name="l02047"></a>02047           <span class="keywordtype">double</span>(histo[histo_num][i*binning+j+<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num)]) - bckgrd;
<a name="l02048"></a>02048     }
<a name="l02049"></a>02049 
<a name="l02050"></a>02050     <span class="keywordflow">return</span> histo_goodBins_minus_bckgrd_vector ;
<a name="l02051"></a>02051   }
<a name="l02052"></a>02052 
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="comment">//*******************************</span>
<a name="l02055"></a>02055 <span class="comment">//Implementation get_asymmetry_array</span>
<a name="l02056"></a>02056 <span class="comment">//*******************************</span>
<a name="l02057"></a>02057 
<a name="l02079"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a7e0f2f5235089d31d12994611490e646">02079</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a7e0f2f5235089d31d12994611490e646" title="Method to obtain an array of double containing the values of the asymmetry between...">MuSR_td_PSI_bin::get_asymmetry_array</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02080"></a>02080                                                 <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02081"></a>02081                                                 <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus , <span class="keywordtype">int</span> offset ,
<a name="l02082"></a>02082                                                 <span class="keywordtype">double</span> y_offset)
<a name="l02083"></a>02083   {
<a name="l02084"></a>02084     <span class="keywordtype">int</span> max_t0 = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02085"></a>02085 
<a name="l02086"></a>02086     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l02087"></a>02087 
<a name="l02088"></a>02088     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02089"></a>02089       <span class="keywordflow">return</span> NULL ;
<a name="l02090"></a>02090 
<a name="l02091"></a>02091     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02092"></a>02092       <span class="keywordflow">return</span> NULL ;
<a name="l02093"></a>02093 
<a name="l02094"></a>02094     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02095"></a>02095       <span class="keywordflow">return</span> NULL ;
<a name="l02096"></a>02096 
<a name="l02097"></a>02097     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02098"></a>02098       <span class="keywordflow">return</span> NULL ;
<a name="l02099"></a>02099 
<a name="l02100"></a>02100 
<a name="l02101"></a>02101     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02102"></a>02102                                                                    higher_bckgrd_plus , binning , offset) ;
<a name="l02103"></a>02103     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> NULL ;
<a name="l02104"></a>02104 
<a name="l02105"></a>02105     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02106"></a>02106                                                                     higher_bckgrd_minus , binning , offset) ;
<a name="l02107"></a>02107     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02108"></a>02108     {
<a name="l02109"></a>02109         <span class="keyword">delete</span> [] dummy_1;
<a name="l02110"></a>02110         <span class="keywordflow">return</span> NULL ;
<a name="l02111"></a>02111     }
<a name="l02112"></a>02112 
<a name="l02113"></a>02113     <span class="keywordtype">double</span> *asymmetry_array = <span class="keyword">new</span> <span class="keywordtype">double</span>[int((<span class="keywordtype">int</span>(length_histo)-max_t0-offset+1)/binning)] ;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115     <span class="keywordflow">if</span> (!asymmetry_array) <span class="keywordflow">return</span> NULL;
<a name="l02116"></a>02116 
<a name="l02117"></a>02117     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-max_t0)/binning) ; i++)
<a name="l02118"></a>02118     {
<a name="l02119"></a>02119        asymmetry_array[i] = (dummy_1[i] - alpha_param * dummy_2[i]) /
<a name="l02120"></a>02120                            (dummy_1[i] + alpha_param * dummy_2[i]) + y_offset ;
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     <span class="keyword">delete</span> [] dummy_1;
<a name="l02124"></a>02124     <span class="keyword">delete</span> [] dummy_2;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="keywordflow">return</span> asymmetry_array ;
<a name="l02127"></a>02127   }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 
<a name="l02130"></a>02130 <span class="comment">//*******************************</span>
<a name="l02131"></a>02131 <span class="comment">//Implementation get_asymmetry_vector</span>
<a name="l02132"></a>02132 <span class="comment">//*******************************</span>
<a name="l02133"></a>02133 
<a name="l02152"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a84fa0972a572f9162da3f13e61d05999">02152</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a84fa0972a572f9162da3f13e61d05999" title="Method to obtain a vector of double containing the values of the asymmetry between...">MuSR_td_PSI_bin::get_asymmetry_vector</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02153"></a>02153                                                  <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02154"></a>02154                                                  <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus , <span class="keywordtype">int</span> offset , <span class="keywordtype">double</span> y_offset)
<a name="l02155"></a>02155   {
<a name="l02156"></a>02156     <span class="keywordtype">int</span> max_t0 = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02157"></a>02157 
<a name="l02158"></a>02158     vector&lt;double&gt; asymmetry_vector ; <span class="comment">// (int((int(length_histo)-max_t0+1)/binning)) ;</span>
<a name="l02159"></a>02159 
<a name="l02160"></a>02160     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> asymmetry_vector;
<a name="l02161"></a>02161 
<a name="l02162"></a>02162     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02163"></a>02163       <span class="keywordflow">return</span> asymmetry_vector ;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02166"></a>02166       <span class="keywordflow">return</span> asymmetry_vector ;
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02169"></a>02169       <span class="keywordflow">return</span> asymmetry_vector ;
<a name="l02170"></a>02170 
<a name="l02171"></a>02171     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02172"></a>02172       <span class="keywordflow">return</span> asymmetry_vector ;
<a name="l02173"></a>02173 
<a name="l02174"></a>02174     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02175"></a>02175                                                                    higher_bckgrd_plus , binning, offset) ;
<a name="l02176"></a>02176     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> asymmetry_vector;
<a name="l02177"></a>02177 
<a name="l02178"></a>02178     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02179"></a>02179                                                                     higher_bckgrd_minus , binning, offset) ;
<a name="l02180"></a>02180     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02181"></a>02181     {
<a name="l02182"></a>02182         <span class="keyword">delete</span> [] dummy_1;
<a name="l02183"></a>02183         <span class="keywordflow">return</span> asymmetry_vector;
<a name="l02184"></a>02184     }
<a name="l02185"></a>02185 
<a name="l02186"></a>02186     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-max_t0-offset)/binning) ; i++)
<a name="l02187"></a>02187       asymmetry_vector.push_back(0.) ;
<a name="l02188"></a>02188 
<a name="l02189"></a>02189     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-max_t0-offset)/binning) ; i++)
<a name="l02190"></a>02190    {
<a name="l02191"></a>02191       asymmetry_vector[i] = (dummy_1[i] - alpha_param * dummy_2[i]) /
<a name="l02192"></a>02192                             (dummy_1[i] + alpha_param * dummy_2[i]) + y_offset ;
<a name="l02193"></a>02193     }
<a name="l02194"></a>02194 
<a name="l02195"></a>02195     <span class="keyword">delete</span> [] dummy_1;
<a name="l02196"></a>02196     <span class="keyword">delete</span> [] dummy_2;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198     <span class="keywordflow">return</span> asymmetry_vector ;
<a name="l02199"></a>02199   }
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 
<a name="l02202"></a>02202 <span class="comment">//*******************************</span>
<a name="l02203"></a>02203 <span class="comment">//Implementation get_error_asymmetry_array</span>
<a name="l02204"></a>02204 <span class="comment">//*******************************</span>
<a name="l02205"></a>02205 
<a name="l02224"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a59a92d0351efa28f2c8387cf163c56df">02224</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a59a92d0351efa28f2c8387cf163c56df" title="Method to obtain an array of double containing the values of the error of the asymmetry...">MuSR_td_PSI_bin::get_error_asymmetry_array</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02225"></a>02225                                                  <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02226"></a>02226                                                  <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus, <span class="keywordtype">int</span> offset)
<a name="l02227"></a>02227   {
<a name="l02228"></a>02228     <span class="keywordtype">int</span> max_t0 = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02229"></a>02229 
<a name="l02230"></a>02230     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l02231"></a>02231 
<a name="l02232"></a>02232     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02233"></a>02233       <span class="keywordflow">return</span> NULL ;
<a name="l02234"></a>02234 
<a name="l02235"></a>02235     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02236"></a>02236       <span class="keywordflow">return</span> NULL ;
<a name="l02237"></a>02237 
<a name="l02238"></a>02238     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02239"></a>02239       <span class="keywordflow">return</span> NULL ;
<a name="l02240"></a>02240 
<a name="l02241"></a>02241     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02242"></a>02242       <span class="keywordflow">return</span> NULL ;
<a name="l02243"></a>02243 
<a name="l02244"></a>02244     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02245"></a>02245                                                           higher_bckgrd_plus , binning, offset) ;
<a name="l02246"></a>02246     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> NULL;
<a name="l02247"></a>02247 
<a name="l02248"></a>02248     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02249"></a>02249                                                           higher_bckgrd_minus , binning, offset) ;
<a name="l02250"></a>02250     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02251"></a>02251     {
<a name="l02252"></a>02252         <span class="keyword">delete</span> [] dummy_1;
<a name="l02253"></a>02253         <span class="keywordflow">return</span> NULL;
<a name="l02254"></a>02254     }
<a name="l02255"></a>02255 
<a name="l02256"></a>02256     <span class="keywordtype">double</span> *error_asymmetry_array = <span class="keyword">new</span> <span class="keywordtype">double</span>[int((<span class="keywordtype">int</span>(length_histo)-max_t0-offset+1)/binning)] ;
<a name="l02257"></a>02257 
<a name="l02258"></a>02258     <span class="keywordflow">if</span> (!error_asymmetry_array) <span class="keywordflow">return</span> NULL;
<a name="l02259"></a>02259 
<a name="l02260"></a>02260     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((length_histo-max_t0-offset)/binning) ; i++)
<a name="l02261"></a>02261     {
<a name="l02262"></a>02262       <span class="keywordflow">if</span> (dummy_1[i] &lt; 0.5 || dummy_2[i] &lt; 0.5 )
<a name="l02263"></a>02263         error_asymmetry_array[i] = 1.0 ;
<a name="l02264"></a>02264       <span class="keywordflow">else</span>
<a name="l02265"></a>02265         error_asymmetry_array[i] = double(2.) * alpha_param * sqrt(dummy_1[i]*dummy_2[i]*(dummy_1[i]+dummy_2[i])) /
<a name="l02266"></a>02266                                    pow(dummy_1[i] + alpha_param * dummy_2[i],2.) ;
<a name="l02267"></a>02267     }
<a name="l02268"></a>02268 
<a name="l02269"></a>02269     <span class="keyword">delete</span> [] dummy_1;
<a name="l02270"></a>02270     <span class="keyword">delete</span> [] dummy_2;
<a name="l02271"></a>02271 
<a name="l02272"></a>02272     <span class="keywordflow">return</span> error_asymmetry_array ;
<a name="l02273"></a>02273   }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 <span class="comment">//*******************************</span>
<a name="l02277"></a>02277 <span class="comment">//Implementation get_error_asymmetry_vector</span>
<a name="l02278"></a>02278 <span class="comment">//*******************************</span>
<a name="l02279"></a>02279 
<a name="l02297"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4190b5520cf28adf2884f7dfa02e1e5a">02297</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4190b5520cf28adf2884f7dfa02e1e5a" title="Method to obtain a vector of double containing the values of the error of the asymmetry...">MuSR_td_PSI_bin::get_error_asymmetry_vector</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02298"></a>02298                                                  <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02299"></a>02299                                                  <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus, <span class="keywordtype">int</span> offset)
<a name="l02300"></a>02300   {
<a name="l02301"></a>02301     <span class="keywordtype">int</span> max_t0 = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303     vector&lt;double&gt; error_asymmetry_vector ; <span class="comment">//(int((int(length_histo)-max_t0+1)/binning)) ;</span>
<a name="l02304"></a>02304 
<a name="l02305"></a>02305     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> error_asymmetry_vector;
<a name="l02306"></a>02306 
<a name="l02307"></a>02307     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02308"></a>02308       <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02309"></a>02309 
<a name="l02310"></a>02310     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02311"></a>02311       <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02312"></a>02312 
<a name="l02313"></a>02313     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02314"></a>02314       <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02315"></a>02315 
<a name="l02316"></a>02316     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02317"></a>02317       <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02318"></a>02318 
<a name="l02319"></a>02319     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02320"></a>02320                                                           higher_bckgrd_plus , binning, offset) ;
<a name="l02321"></a>02321     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02324"></a>02324                                                           higher_bckgrd_minus , binning, offset) ;
<a name="l02325"></a>02325     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02326"></a>02326     {
<a name="l02327"></a>02327        <span class="keyword">delete</span> [] dummy_1;
<a name="l02328"></a>02328        <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02329"></a>02329     }
<a name="l02330"></a>02330 
<a name="l02331"></a>02331     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo)-max_t0-offset)/binning) ; i++)
<a name="l02332"></a>02332       error_asymmetry_vector.push_back(0.) ;
<a name="l02333"></a>02333 
<a name="l02334"></a>02334     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int((<span class="keywordtype">int</span>(length_histo-max_t0-offset))/binning) ; i++)
<a name="l02335"></a>02335     {
<a name="l02336"></a>02336        <span class="keywordflow">if</span> (dummy_1[i] &lt; 0.5 || dummy_2[i] &lt; 0.5 )
<a name="l02337"></a>02337          error_asymmetry_vector[i] = 1.0 ;
<a name="l02338"></a>02338        <span class="keywordflow">else</span>
<a name="l02339"></a>02339          error_asymmetry_vector[i] = double(2.) * alpha_param * sqrt(dummy_1[i]*dummy_2[i]*(dummy_1[i]+dummy_2[i])) /
<a name="l02340"></a>02340                                      pow(dummy_1[i] + alpha_param * dummy_2[i],2.) ;
<a name="l02341"></a>02341     }
<a name="l02342"></a>02342 
<a name="l02343"></a>02343     <span class="keyword">delete</span> [] dummy_1;
<a name="l02344"></a>02344     <span class="keyword">delete</span> [] dummy_2;
<a name="l02345"></a>02345 
<a name="l02346"></a>02346     <span class="keywordflow">return</span> error_asymmetry_vector ;
<a name="l02347"></a>02347   }
<a name="l02348"></a>02348 
<a name="l02349"></a>02349 
<a name="l02350"></a>02350 <span class="comment">//*******************************</span>
<a name="l02351"></a>02351 <span class="comment">//Implementation get_asymmetry_goodBins_array</span>
<a name="l02352"></a>02352 <span class="comment">//*******************************</span>
<a name="l02353"></a>02353 
<a name="l02373"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a97850739c61c2af7866b324c1c596995">02373</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a97850739c61c2af7866b324c1c596995" title="Method to obtain an array of double containing the values of the asymmetry between...">MuSR_td_PSI_bin::get_asymmetry_goodBins_array</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02374"></a>02374                                                 <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02375"></a>02375                                                 <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus)
<a name="l02376"></a>02376   {
<a name="l02377"></a>02377     <span class="keywordtype">int</span> hsize = int((tmin(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus),
<a name="l02378"></a>02378       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus))+1)/binning) ;
<a name="l02379"></a>02379 
<a name="l02380"></a>02380     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l02381"></a>02381 
<a name="l02382"></a>02382     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02383"></a>02383       <span class="keywordflow">return</span> NULL ;
<a name="l02384"></a>02384 
<a name="l02385"></a>02385     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02386"></a>02386       <span class="keywordflow">return</span> NULL ;
<a name="l02387"></a>02387 
<a name="l02388"></a>02388     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02389"></a>02389       <span class="keywordflow">return</span> NULL ;
<a name="l02390"></a>02390 
<a name="l02391"></a>02391     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02392"></a>02392       <span class="keywordflow">return</span> NULL ;
<a name="l02393"></a>02393 
<a name="l02394"></a>02394     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02395"></a>02395                                                           higher_bckgrd_plus , binning) ;
<a name="l02396"></a>02396     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> NULL;
<a name="l02397"></a>02397 
<a name="l02398"></a>02398     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02399"></a>02399                                                           higher_bckgrd_minus , binning) ;
<a name="l02400"></a>02400     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02401"></a>02401     {
<a name="l02402"></a>02402        <span class="keyword">delete</span> [] dummy_1;
<a name="l02403"></a>02403        <span class="keywordflow">return</span> NULL;
<a name="l02404"></a>02404     }
<a name="l02405"></a>02405 
<a name="l02406"></a>02406     <span class="keywordtype">int</span> hstart = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02407"></a>02407 
<a name="l02408"></a>02408     <span class="keywordtype">double</span> *asymmetry_goodBins_array = <span class="keyword">new</span> <span class="keywordtype">double</span>[hsize] ;
<a name="l02409"></a>02409 
<a name="l02410"></a>02410     <span class="keywordflow">if</span> (!asymmetry_goodBins_array) <span class="keywordflow">return</span> NULL;
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; hsize ; i++)
<a name="l02413"></a>02413     {
<a name="l02414"></a>02414        asymmetry_goodBins_array[i] = (dummy_1[i+hstart] - alpha_param * dummy_2[i+hstart]) /
<a name="l02415"></a>02415                                      (dummy_1[i+hstart] + alpha_param * dummy_2[i+hstart]) ;
<a name="l02416"></a>02416     }
<a name="l02417"></a>02417 
<a name="l02418"></a>02418     <span class="keyword">delete</span> [] dummy_1;
<a name="l02419"></a>02419     <span class="keyword">delete</span> [] dummy_2;
<a name="l02420"></a>02420 
<a name="l02421"></a>02421     <span class="keywordflow">return</span> asymmetry_goodBins_array ;
<a name="l02422"></a>02422   }
<a name="l02423"></a>02423 
<a name="l02424"></a>02424 
<a name="l02425"></a>02425 <span class="comment">//*******************************</span>
<a name="l02426"></a>02426 <span class="comment">//Implementation get_asymmetry_goodBins_vector</span>
<a name="l02427"></a>02427 <span class="comment">//*******************************</span>
<a name="l02428"></a>02428 
<a name="l02447"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad82abca2d25027bc63d6e86ce05f0207">02447</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad82abca2d25027bc63d6e86ce05f0207" title="Method to obtain a vector of double containing the values of the asymmetry between...">MuSR_td_PSI_bin::get_asymmetry_goodBins_vector</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02448"></a>02448                                                  <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02449"></a>02449                                                  <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus)
<a name="l02450"></a>02450   {
<a name="l02451"></a>02451     <span class="keywordtype">int</span> hsize = int((tmin(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus),
<a name="l02452"></a>02452       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus))+1)/binning) ;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454     vector&lt;double&gt; asymmetry_goodBins_vector ;
<a name="l02455"></a>02455 
<a name="l02456"></a>02456     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> asymmetry_goodBins_vector;
<a name="l02457"></a>02457 
<a name="l02458"></a>02458     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02459"></a>02459       <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02460"></a>02460 
<a name="l02461"></a>02461     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02462"></a>02462       <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02463"></a>02463 
<a name="l02464"></a>02464     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02465"></a>02465       <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02466"></a>02466 
<a name="l02467"></a>02467     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02468"></a>02468       <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02469"></a>02469 
<a name="l02470"></a>02470     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02471"></a>02471                                                           higher_bckgrd_plus , binning) ;
<a name="l02472"></a>02472     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02473"></a>02473 
<a name="l02474"></a>02474     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02475"></a>02475                                                                     higher_bckgrd_minus , binning) ;
<a name="l02476"></a>02476     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02477"></a>02477     {
<a name="l02478"></a>02478       <span class="keyword">delete</span> [] dummy_1;
<a name="l02479"></a>02479       <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02480"></a>02480     }
<a name="l02481"></a>02481 
<a name="l02482"></a>02482     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; hsize ; i++)
<a name="l02483"></a>02483       asymmetry_goodBins_vector.push_back(0.) ;
<a name="l02484"></a>02484 
<a name="l02485"></a>02485     <span class="keywordtype">int</span> hstart = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02486"></a>02486 
<a name="l02487"></a>02487     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; hsize ; i++)
<a name="l02488"></a>02488     {
<a name="l02489"></a>02489        asymmetry_goodBins_vector[i] = (dummy_1[i+hstart] - alpha_param * dummy_2[i+hstart]) /
<a name="l02490"></a>02490                                       (dummy_1[i+hstart] + alpha_param * dummy_2[i+hstart]) ;
<a name="l02491"></a>02491     }
<a name="l02492"></a>02492     <span class="keyword">delete</span> [] dummy_1;
<a name="l02493"></a>02493     <span class="keyword">delete</span> [] dummy_2;
<a name="l02494"></a>02494 
<a name="l02495"></a>02495     <span class="keywordflow">return</span> asymmetry_goodBins_vector ;
<a name="l02496"></a>02496   }
<a name="l02497"></a>02497 
<a name="l02498"></a>02498 
<a name="l02499"></a>02499 <span class="comment">//*******************************</span>
<a name="l02500"></a>02500 <span class="comment">//Implementation get_error_asymmetry_goodBins_array</span>
<a name="l02501"></a>02501 <span class="comment">//*******************************</span>
<a name="l02502"></a>02502 
<a name="l02521"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad22fe70445d6487d8c073bb2bd2ca083">02521</a>  <span class="keywordtype">double</span> * <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad22fe70445d6487d8c073bb2bd2ca083" title="Method to obtain an array of double containing the values of the error of the asymmetry...">MuSR_td_PSI_bin::get_error_asymmetry_goodBins_array</a>(<span class="keywordtype">int</span> histo_num_plus , <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02522"></a>02522                                                  <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02523"></a>02523                                                  <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus)
<a name="l02524"></a>02524   {
<a name="l02525"></a>02525     <span class="keywordtype">int</span> hsize = int((tmin(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_plus)
<a name="l02526"></a>02526                             -<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus),
<a name="l02527"></a>02527                           <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_minus)
<a name="l02528"></a>02528                             -<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus))+1)/binning) ;
<a name="l02529"></a>02529 
<a name="l02530"></a>02530     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> NULL;
<a name="l02531"></a>02531 
<a name="l02532"></a>02532     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02533"></a>02533       <span class="keywordflow">return</span> NULL ;
<a name="l02534"></a>02534 
<a name="l02535"></a>02535     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02536"></a>02536       <span class="keywordflow">return</span> NULL ;
<a name="l02537"></a>02537 
<a name="l02538"></a>02538     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02539"></a>02539       <span class="keywordflow">return</span> NULL ;
<a name="l02540"></a>02540 
<a name="l02541"></a>02541     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02542"></a>02542       <span class="keywordflow">return</span> NULL ;
<a name="l02543"></a>02543 
<a name="l02544"></a>02544     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , 
<a name="l02545"></a>02545                                  lower_bckgrd_plus , higher_bckgrd_plus , binning) ;
<a name="l02546"></a>02546     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> NULL;
<a name="l02547"></a>02547 
<a name="l02548"></a>02548     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , 
<a name="l02549"></a>02549                                lower_bckgrd_minus , higher_bckgrd_minus , binning) ;
<a name="l02550"></a>02550     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02551"></a>02551     {
<a name="l02552"></a>02552       <span class="keyword">delete</span> [] dummy_1;
<a name="l02553"></a>02553       <span class="keywordflow">return</span> NULL;
<a name="l02554"></a>02554     }
<a name="l02555"></a>02555     <span class="keywordtype">int</span> hstart = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),
<a name="l02556"></a>02556                       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02557"></a>02557 
<a name="l02558"></a>02558     <span class="keywordtype">double</span> *error_asymmetry_goodBins_array = <span class="keyword">new</span> <span class="keywordtype">double</span>[hsize] ;
<a name="l02559"></a>02559 
<a name="l02560"></a>02560     <span class="keywordflow">if</span> (!error_asymmetry_goodBins_array) <span class="keywordflow">return</span> NULL;
<a name="l02561"></a>02561 
<a name="l02562"></a>02562     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; hsize ; i++)
<a name="l02563"></a>02563     {
<a name="l02564"></a>02564       <span class="keywordflow">if</span> (dummy_1[i+hstart] &lt; 0.5 || dummy_2[i+hstart] &lt; 0.5 )
<a name="l02565"></a>02565         error_asymmetry_goodBins_array[i] = 1.0 ;
<a name="l02566"></a>02566       <span class="keywordflow">else</span>
<a name="l02567"></a>02567         error_asymmetry_goodBins_array[i] = 
<a name="l02568"></a>02568           double(2.) * alpha_param * sqrt(dummy_1[i+hstart]*dummy_2[i+hstart]
<a name="l02569"></a>02569                                           *(dummy_1[i+hstart]+dummy_2[i+hstart])) /
<a name="l02570"></a>02570                           pow(dummy_1[i+hstart] + alpha_param * dummy_2[i+hstart],2.) ;
<a name="l02571"></a>02571     }
<a name="l02572"></a>02572 
<a name="l02573"></a>02573     <span class="keyword">delete</span> [] dummy_1;
<a name="l02574"></a>02574     <span class="keyword">delete</span> [] dummy_2;
<a name="l02575"></a>02575 
<a name="l02576"></a>02576     <span class="keywordflow">return</span> error_asymmetry_goodBins_array ;
<a name="l02577"></a>02577   }
<a name="l02578"></a>02578 
<a name="l02579"></a>02579 
<a name="l02580"></a>02580 <span class="comment">//*******************************</span>
<a name="l02581"></a>02581 <span class="comment">//Implementation get_error_asymmetry_goodBins_vector</span>
<a name="l02582"></a>02582 <span class="comment">//*******************************</span>
<a name="l02583"></a>02583 
<a name="l02605"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac02e2efc7b66e2e0a9bf86b47a8fc3ae">02605</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac02e2efc7b66e2e0a9bf86b47a8fc3ae" title="Method to obtain a vector of double containing the values of the error of the asymmetry...">MuSR_td_PSI_bin::get_error_asymmetry_goodBins_vector</a>(<span class="keywordtype">int</span> histo_num_plus ,
<a name="l02606"></a>02606                                               <span class="keywordtype">int</span> histo_num_minus , <span class="keywordtype">double</span> alpha_param ,
<a name="l02607"></a>02607                                               <span class="keywordtype">int</span> binning , <span class="keywordtype">int</span> lower_bckgrd_plus , 
<a name="l02608"></a>02608                                               <span class="keywordtype">int</span> higher_bckgrd_plus ,
<a name="l02609"></a>02609                                               <span class="keywordtype">int</span> lower_bckgrd_minus , <span class="keywordtype">int</span> higher_bckgrd_minus)
<a name="l02610"></a>02610   {
<a name="l02611"></a>02611     <span class="keywordtype">int</span> hsize = int((tmin(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus),
<a name="l02612"></a>02612       <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">get_lastGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus))+1)/binning) ;
<a name="l02613"></a>02613 
<a name="l02614"></a>02614     vector&lt;double&gt; error_asymmetry_goodBins_vector ;
<a name="l02615"></a>02615 
<a name="l02616"></a>02616     <span class="keywordflow">if</span> (!readingok) <span class="keywordflow">return</span> error_asymmetry_goodBins_vector;
<a name="l02617"></a>02617 
<a name="l02618"></a>02618     <span class="keywordflow">if</span> ( histo_num_plus &lt; 0 || histo_num_plus &gt;= <span class="keywordtype">int</span>(number_histo) || binning &lt;= 0 )
<a name="l02619"></a>02619       <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02620"></a>02620 
<a name="l02621"></a>02621     <span class="keywordflow">if</span> ( histo_num_minus &lt; 0 || histo_num_minus &gt;= <span class="keywordtype">int</span>(number_histo) )
<a name="l02622"></a>02622       <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02623"></a>02623 
<a name="l02624"></a>02624     <span class="keywordflow">if</span> ( lower_bckgrd_plus &lt; 0 || higher_bckgrd_plus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_plus &gt; higher_bckgrd_plus )
<a name="l02625"></a>02625       <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02626"></a>02626 
<a name="l02627"></a>02627     <span class="keywordflow">if</span> ( lower_bckgrd_minus &lt; 0 || higher_bckgrd_minus &gt;= <span class="keywordtype">int</span>(length_histo) || lower_bckgrd_minus &gt; higher_bckgrd_minus )
<a name="l02628"></a>02628       <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02629"></a>02629 
<a name="l02630"></a>02630     <span class="keywordtype">double</span> *dummy_1 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_plus , lower_bckgrd_plus ,
<a name="l02631"></a>02631                                                           higher_bckgrd_plus , binning) ;
<a name="l02632"></a>02632     <span class="keywordflow">if</span> (dummy_1 == NULL) <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02633"></a>02633 
<a name="l02634"></a>02634     <span class="keywordtype">double</span> *dummy_2 = <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a40cbb601e0f843173f0182cfedabd94b" title="Method to obtain an array of type double containing the values of the histogram &amp;lt;histo_num&amp;gt;...">get_histo_fromt0_minus_bckgrd_array</a>(histo_num_minus , lower_bckgrd_minus ,
<a name="l02635"></a>02635                                                           higher_bckgrd_minus , binning) ;
<a name="l02636"></a>02636     <span class="keywordflow">if</span> (dummy_2 == NULL)
<a name="l02637"></a>02637     {
<a name="l02638"></a>02638       <span class="keyword">delete</span> [] dummy_1;
<a name="l02639"></a>02639       <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02640"></a>02640     }
<a name="l02641"></a>02641 
<a name="l02642"></a>02642     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; hsize ; i++)
<a name="l02643"></a>02643       error_asymmetry_goodBins_vector.push_back(0.) ;
<a name="l02644"></a>02644 
<a name="l02645"></a>02645     <span class="keywordtype">int</span> hstart = tmax(<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_plus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_plus),<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">get_firstGood_int</a>(histo_num_minus)-<a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">get_t0_int</a>(histo_num_minus)) ;
<a name="l02646"></a>02646 
<a name="l02647"></a>02647     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; hsize ; i++)
<a name="l02648"></a>02648     {
<a name="l02649"></a>02649      <span class="keywordflow">if</span> (dummy_1[i+hstart] &lt; 0.5 || dummy_2[i+hstart] &lt; 0.5 )
<a name="l02650"></a>02650       error_asymmetry_goodBins_vector[i] = 1.0 ;
<a name="l02651"></a>02651      <span class="keywordflow">else</span>
<a name="l02652"></a>02652        error_asymmetry_goodBins_vector[i] = double(2.) * alpha_param 
<a name="l02653"></a>02653          * sqrt(dummy_1[i+hstart]*dummy_2[i+hstart]*(dummy_1[i+hstart]+dummy_2[i+hstart])) /
<a name="l02654"></a>02654           pow(dummy_1[i+hstart] + alpha_param * dummy_2[i+hstart],2.) ;
<a name="l02655"></a>02655     }
<a name="l02656"></a>02656 
<a name="l02657"></a>02657     <span class="keyword">delete</span> [] dummy_1;
<a name="l02658"></a>02658     <span class="keyword">delete</span> [] dummy_2;
<a name="l02659"></a>02659 
<a name="l02660"></a>02660     <span class="keywordflow">return</span> error_asymmetry_goodBins_vector ;
<a name="l02661"></a>02661   }
<a name="l02662"></a>02662 
<a name="l02663"></a>02663 
<a name="l02664"></a>02664 <span class="comment">//*******************************</span>
<a name="l02665"></a>02665 <span class="comment">//Implementation get_numberScaler_int</span>
<a name="l02666"></a>02666 <span class="comment">//*******************************</span>
<a name="l02667"></a>02667 
<a name="l02671"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae3ab783087381e7e7360c85564af9817">02671</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae3ab783087381e7e7360c85564af9817" title="Method returning an integer representing the number of histograms.">MuSR_td_PSI_bin::get_numberScaler_int</a>()
<a name="l02672"></a>02672   {
<a name="l02673"></a>02673     <span class="keywordflow">return</span> int(number_scaler) ;
<a name="l02674"></a>02674   }
<a name="l02675"></a>02675 
<a name="l02676"></a>02676 <span class="comment">//*******************************</span>
<a name="l02677"></a>02677 <span class="comment">//Implementation get_scalers_vector</span>
<a name="l02678"></a>02678 <span class="comment">//*******************************</span>
<a name="l02679"></a>02679 
<a name="l02683"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad747183a2e5f73089cf9d25dcedf1e08">02683</a>  vector&lt;long&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad747183a2e5f73089cf9d25dcedf1e08" title="Method providing a vector of long containing the values of the scalers.">MuSR_td_PSI_bin::get_scalers_vector</a>()
<a name="l02684"></a>02684   {
<a name="l02685"></a>02685     vector&lt;long&gt; scalers_vect(number_scaler) ;
<a name="l02686"></a>02686 
<a name="l02687"></a>02687     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0 ; i &lt; number_scaler ; i++ )
<a name="l02688"></a>02688       scalers_vect[i] = <span class="keywordtype">long</span>(scalers[i]) ;
<a name="l02689"></a>02689 
<a name="l02690"></a>02690     <span class="keywordflow">return</span> scalers_vect ;
<a name="l02691"></a>02691   }
<a name="l02692"></a>02692 
<a name="l02693"></a>02693 
<a name="l02694"></a>02694 <span class="comment">//*******************************</span>
<a name="l02695"></a>02695 <span class="comment">//Implementation get_max_t0_int</span>
<a name="l02696"></a>02696 <span class="comment">//*******************************</span>
<a name="l02697"></a>02697 
<a name="l02701"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a2bc16f02fcf82af9ab0ed1be64049e3d">02701</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a2bc16f02fcf82af9ab0ed1be64049e3d" title="Method to determine the maximum value of the t0 bins.">MuSR_td_PSI_bin::get_max_t0_int</a>()
<a name="l02702"></a>02702   {
<a name="l02703"></a>02703     <span class="keywordtype">int</span> max_t0 = 0 ;
<a name="l02704"></a>02704 
<a name="l02705"></a>02705     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(number_histo) ; i++)
<a name="l02706"></a>02706     {
<a name="l02707"></a>02707        <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(integer_t0[i]) &gt; max_t0)
<a name="l02708"></a>02708          max_t0 = <span class="keywordtype">int</span>(integer_t0[i]) ;
<a name="l02709"></a>02709     }
<a name="l02710"></a>02710     <span class="keywordflow">return</span> max_t0 ;
<a name="l02711"></a>02711   }
<a name="l02712"></a>02712 
<a name="l02713"></a>02713 
<a name="l02714"></a>02714 <span class="comment">//*******************************</span>
<a name="l02715"></a>02715 <span class="comment">//Implementation get_max_2_t0_int</span>
<a name="l02716"></a>02716 <span class="comment">//*******************************</span>
<a name="l02717"></a>02717 
<a name="l02723"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a630ede5b9560a83771152f5776ab17cf">02723</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a630ede5b9560a83771152f5776ab17cf" title="Method to determine the maximum value of the last good bins of 2 histograms.">MuSR_td_PSI_bin::get_max_2_t0_int</a>(<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j)
<a name="l02724"></a>02724   {
<a name="l02725"></a>02725     <span class="keywordflow">if</span> (( k &lt; 0 || k &gt;= <span class="keywordtype">int</span>(number_histo)) || ( j &lt; 0 || j &gt;= <span class="keywordtype">int</span>(number_histo)))
<a name="l02726"></a>02726       <span class="keywordflow">return</span> -1 ;
<a name="l02727"></a>02727 
<a name="l02728"></a>02728     <span class="keywordtype">int</span> max_t0 = int(integer_t0[j]) ;
<a name="l02729"></a>02729     <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(integer_t0[k]) &gt;= max_t0)
<a name="l02730"></a>02730       max_t0 = int(integer_t0[k]) ;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732     <span class="keywordflow">return</span> max_t0 ;
<a name="l02733"></a>02733   }
<a name="l02734"></a>02734 
<a name="l02735"></a>02735 
<a name="l02736"></a>02736 <span class="comment">//*******************************</span>
<a name="l02737"></a>02737 <span class="comment">//Implementation get_min_2_t0_int</span>
<a name="l02738"></a>02738 <span class="comment">//*******************************</span>
<a name="l02739"></a>02739 
<a name="l02745"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aa9bcf322d5197990f42d5a2b4620efa4">02745</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aa9bcf322d5197990f42d5a2b4620efa4" title="Method to determine the minimum value of the last good bins of 2 histograms.">MuSR_td_PSI_bin::get_min_2_t0_int</a>(<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j)
<a name="l02746"></a>02746   {
<a name="l02747"></a>02747     <span class="keywordflow">if</span> (( k &lt; 0 || k &gt;= <span class="keywordtype">int</span>(number_histo)) || ( j &lt; 0 || j &gt;= <span class="keywordtype">int</span>(number_histo)))
<a name="l02748"></a>02748       <span class="keywordflow">return</span> -1 ;
<a name="l02749"></a>02749 
<a name="l02750"></a>02750     <span class="keywordtype">int</span> min_t0 = int(integer_t0[j]) ;
<a name="l02751"></a>02751     <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(integer_t0[k]) &lt;= min_t0)
<a name="l02752"></a>02752       min_t0 = int(integer_t0[k]) ;
<a name="l02753"></a>02753 
<a name="l02754"></a>02754     <span class="keywordflow">return</span> min_t0 ;
<a name="l02755"></a>02755   }
<a name="l02756"></a>02756 
<a name="l02757"></a>02757 
<a name="l02758"></a>02758 <span class="comment">//*******************************</span>
<a name="l02759"></a>02759 <span class="comment">//Implementation get_min_t0_int</span>
<a name="l02760"></a>02760 <span class="comment">//*******************************</span>
<a name="l02761"></a>02761 
<a name="l02765"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a402e5c43f3a1e5d501435eb1057f9b7f">02765</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a402e5c43f3a1e5d501435eb1057f9b7f" title="Method to determine the minimum value of the t0 bins.">MuSR_td_PSI_bin::get_min_t0_int</a>()
<a name="l02766"></a>02766   {
<a name="l02767"></a>02767     <span class="keywordtype">int</span> min_t0 = int(length_histo) ;
<a name="l02768"></a>02768 
<a name="l02769"></a>02769     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(number_histo) ; i++)
<a name="l02770"></a>02770     {
<a name="l02771"></a>02771       <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(integer_t0[i]) &lt; min_t0)
<a name="l02772"></a>02772         min_t0 = <span class="keywordtype">int</span>(integer_t0[i]) ;
<a name="l02773"></a>02773     }
<a name="l02774"></a>02774 
<a name="l02775"></a>02775     <span class="keywordflow">return</span> min_t0 ;
<a name="l02776"></a>02776   }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778 
<a name="l02779"></a>02779  <span class="comment">//*******************************</span>
<a name="l02780"></a>02780 <span class="comment">//Implementation get_binWidth_ps</span>
<a name="l02781"></a>02781 <span class="comment">//*******************************</span>
<a name="l02782"></a>02782 
<a name="l02786"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a842cb7dcfca380da40acc4b30f0683e5">02786</a>  <span class="keywordtype">double</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a842cb7dcfca380da40acc4b30f0683e5" title="Method returning a double representing the bin-width in picoseconds.">MuSR_td_PSI_bin::get_binWidth_ps</a>()
<a name="l02787"></a>02787   {
<a name="l02788"></a>02788     <span class="keywordflow">return</span> double((<span class="keywordtype">double</span>)bin_width*(<span class="keywordtype">double</span>)1000000.) ;
<a name="l02789"></a>02789   }
<a name="l02790"></a>02790 
<a name="l02791"></a>02791 
<a name="l02792"></a>02792 <span class="comment">//*******************************</span>
<a name="l02793"></a>02793 <span class="comment">//Implementation get_binWidth_ns</span>
<a name="l02794"></a>02794 <span class="comment">//*******************************</span>
<a name="l02795"></a>02795 
<a name="l02799"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a2b3af1fb9d6e3398305bc259b26d1c82">02799</a>  <span class="keywordtype">double</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a2b3af1fb9d6e3398305bc259b26d1c82" title="Method returning a double representing the bin-width in nanoseconds.">MuSR_td_PSI_bin::get_binWidth_ns</a>()
<a name="l02800"></a>02800   {
<a name="l02801"></a>02801     <span class="keywordflow">return</span> double((<span class="keywordtype">double</span>)bin_width*(<span class="keywordtype">double</span>)1000.) ;
<a name="l02802"></a>02802   }
<a name="l02803"></a>02803 
<a name="l02804"></a>02804 <span class="comment">//*******************************</span>
<a name="l02805"></a>02805 <span class="comment">//Implementation get_binWidth_us</span>
<a name="l02806"></a>02806 <span class="comment">//*******************************</span>
<a name="l02807"></a>02807 
<a name="l02811"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#adc13dce6f029560c0de7917f25dc00fb">02811</a>  <span class="keywordtype">double</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#adc13dce6f029560c0de7917f25dc00fb" title="Method returning a double representing the bin-width in microseconds.">MuSR_td_PSI_bin::get_binWidth_us</a>()
<a name="l02812"></a>02812   {
<a name="l02813"></a>02813     <span class="keywordflow">return</span> double(bin_width) ;
<a name="l02814"></a>02814   }
<a name="l02815"></a>02815 
<a name="l02816"></a>02816 
<a name="l02817"></a>02817 <span class="comment">//*******************************</span>
<a name="l02818"></a>02818 <span class="comment">//Implementation get_histoLength_bin</span>
<a name="l02819"></a>02819 <span class="comment">//*******************************</span>
<a name="l02820"></a>02820 
<a name="l02824"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac7e5face6513b46733d4c00facc51a1d">02824</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac7e5face6513b46733d4c00facc51a1d" title="Method returning an integer representing the histogram length in bins.">MuSR_td_PSI_bin::get_histoLength_bin</a>()
<a name="l02825"></a>02825   {
<a name="l02826"></a>02826     <span class="keywordflow">return</span> int(length_histo) ;
<a name="l02827"></a>02827   }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 
<a name="l02830"></a>02830 <span class="comment">//*******************************</span>
<a name="l02831"></a>02831 <span class="comment">//Implementation get_numberHisto_int</span>
<a name="l02832"></a>02832 <span class="comment">//*******************************</span>
<a name="l02833"></a>02833 
<a name="l02837"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a2ef401db2aca844ed67735133c90f9bf">02837</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a2ef401db2aca844ed67735133c90f9bf" title="Method returning an integer representing the number of histograms.">MuSR_td_PSI_bin::get_numberHisto_int</a>()
<a name="l02838"></a>02838   {
<a name="l02839"></a>02839     <span class="keywordflow">return</span> int(number_histo) ;
<a name="l02840"></a>02840   }
<a name="l02841"></a>02841 
<a name="l02842"></a>02842 
<a name="l02843"></a>02843 <span class="comment">//*******************************</span>
<a name="l02844"></a>02844 <span class="comment">//Implementation get_totalEvents_long</span>
<a name="l02845"></a>02845 <span class="comment">//*******************************</span>
<a name="l02846"></a>02846 
<a name="l02850"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a46f62cc635ef1ce99192094a3e3ea437">02850</a>  <span class="keywordtype">long</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a46f62cc635ef1ce99192094a3e3ea437" title="Method returning a long representing the total number of events.">MuSR_td_PSI_bin::get_totalEvents_long</a>()
<a name="l02851"></a>02851   {
<a name="l02852"></a>02852     <span class="keywordflow">return</span> long(total_events) ;
<a name="l02853"></a>02853   }
<a name="l02854"></a>02854 
<a name="l02855"></a>02855 
<a name="l02856"></a>02856 <span class="comment">//*******************************</span>
<a name="l02857"></a>02857 <span class="comment">//Implementation get_eventsHisto_long</span>
<a name="l02858"></a>02858 <span class="comment">//*******************************</span>
<a name="l02859"></a>02859 
<a name="l02865"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a53cd0b797bfd4184bb3caee8af8ca404">02865</a>  <span class="keywordtype">long</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a53cd0b797bfd4184bb3caee8af8ca404" title="Method returning a long representing the number of events in a specified histograms...">MuSR_td_PSI_bin::get_eventsHisto_long</a>(<span class="keywordtype">int</span> i)
<a name="l02866"></a>02866   {
<a name="l02867"></a>02867     <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= number_histo)
<a name="l02868"></a>02868       <span class="keywordflow">return</span> -1 ;
<a name="l02869"></a>02869     <span class="keywordflow">else</span>
<a name="l02870"></a>02870       <span class="keywordflow">return</span> long(events_per_histo[i]) ;
<a name="l02871"></a>02871   }
<a name="l02872"></a>02872 
<a name="l02873"></a>02873 
<a name="l02874"></a>02874 <span class="comment">//*******************************</span>
<a name="l02875"></a>02875 <span class="comment">//Implementation get_eventsHisto_vector</span>
<a name="l02876"></a>02876 <span class="comment">//*******************************</span>
<a name="l02877"></a>02877 
<a name="l02881"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae3424d1f2652dd5f070affb0c729d154">02881</a>   vector&lt;long&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae3424d1f2652dd5f070affb0c729d154" title="Method returning a vector of long containing the number of events in the histograms...">MuSR_td_PSI_bin::get_eventsHisto_vector</a>()
<a name="l02882"></a>02882   {
<a name="l02883"></a>02883     vector&lt;long&gt; eventsHisto(number_histo) ;
<a name="l02884"></a>02884 
<a name="l02885"></a>02885     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0 ; i &lt; number_histo ; i++ )
<a name="l02886"></a>02886       eventsHisto[i] = <span class="keywordtype">long</span>(events_per_histo[i]) ;
<a name="l02887"></a>02887     <span class="keywordflow">return</span> eventsHisto ;
<a name="l02888"></a>02888   }
<a name="l02889"></a>02889 
<a name="l02890"></a>02890 <span class="comment">//*******************************</span>
<a name="l02891"></a>02891 <span class="comment">//Implementation get_t0_double</span>
<a name="l02892"></a>02892 <span class="comment">//*******************************</span>
<a name="l02893"></a>02893 
<a name="l02899"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac500475047d138c676a6782f4851e8d5">02899</a>  <span class="keywordtype">double</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ac500475047d138c676a6782f4851e8d5" title="Method returning a double representing the t0 point (from the &amp;quot;real&amp;quot; t0...">MuSR_td_PSI_bin::get_t0_double</a>(<span class="keywordtype">int</span> i)
<a name="l02900"></a>02900   {
<a name="l02901"></a>02901     <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l02902"></a>02902       <span class="keywordflow">return</span> -1. ;
<a name="l02903"></a>02903     <span class="keywordflow">else</span>
<a name="l02904"></a>02904       <span class="keywordflow">return</span> double(real_t0[i]) ;
<a name="l02905"></a>02905   }
<a name="l02906"></a>02906 
<a name="l02907"></a>02907 
<a name="l02908"></a>02908 <span class="comment">//*******************************</span>
<a name="l02909"></a>02909 <span class="comment">//Implementation get_default_binning</span>
<a name="l02910"></a>02910 <span class="comment">//*******************************</span>
<a name="l02911"></a>02911 
<a name="l02915"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a59cf59a93a6f5fc1293b6d2b5a63579f">02915</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a59cf59a93a6f5fc1293b6d2b5a63579f" title="Method returning an integer representing the default binning.">MuSR_td_PSI_bin::get_default_binning</a>()
<a name="l02916"></a>02916   {
<a name="l02917"></a>02917     <span class="keywordflow">if</span> (default_binning &lt; 1)
<a name="l02918"></a>02918       <span class="keywordflow">return</span> 1;
<a name="l02919"></a>02919     <span class="keywordflow">else</span>
<a name="l02920"></a>02920       <span class="keywordflow">return</span> default_binning ;
<a name="l02921"></a>02921   }
<a name="l02922"></a>02922 
<a name="l02923"></a>02923 <span class="comment">//*******************************</span>
<a name="l02924"></a>02924 <span class="comment">//Implementation get_t0_int</span>
<a name="l02925"></a>02925 <span class="comment">//*******************************</span>
<a name="l02926"></a>02926 
<a name="l02932"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f">02932</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a120b97137988adfc3898bb9e7549771f" title="Method returning an integer representing the t0 point (from the &amp;quot;integer&amp;quot;...">MuSR_td_PSI_bin::get_t0_int</a>(<span class="keywordtype">int</span> i)
<a name="l02933"></a>02933   {
<a name="l02934"></a>02934     <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l02935"></a>02935       <span class="keywordflow">return</span> -1 ;
<a name="l02936"></a>02936     <span class="keywordflow">else</span>
<a name="l02937"></a>02937       <span class="keywordflow">return</span> int(integer_t0[i]) ;
<a name="l02938"></a>02938   }
<a name="l02939"></a>02939 
<a name="l02940"></a>02940 <span class="comment">//*******************************</span>
<a name="l02941"></a>02941 <span class="comment">//Implementation get_t0_vector</span>
<a name="l02942"></a>02942 <span class="comment">//*******************************</span>
<a name="l02943"></a>02943 
<a name="l02947"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afd6f9089ef8c33e008e7b1c40e17f02f">02947</a>  vector&lt;int&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afd6f9089ef8c33e008e7b1c40e17f02f" title="Method returning a vector of integer containing the t0 values of the histograms specified...">MuSR_td_PSI_bin::get_t0_vector</a>()
<a name="l02948"></a>02948   {
<a name="l02949"></a>02949     vector&lt;int&gt; t0(number_histo) ;
<a name="l02950"></a>02950 
<a name="l02951"></a>02951     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0 ; i &lt; int(number_histo) ; i++ )
<a name="l02952"></a>02952         t0[i] = <span class="keywordtype">int</span>(integer_t0[i]) ;
<a name="l02953"></a>02953 
<a name="l02954"></a>02954     <span class="keywordflow">return</span> t0 ;
<a name="l02955"></a>02955   }
<a name="l02956"></a>02956 
<a name="l02957"></a>02957 
<a name="l02958"></a>02958 <span class="comment">//*******************************</span>
<a name="l02959"></a>02959 <span class="comment">//Implementation get_firstGood_int</span>
<a name="l02960"></a>02960 <span class="comment">//*******************************</span>
<a name="l02961"></a>02961 
<a name="l02967"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923">02967</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad091d4191f9b3a6c3441601150911923" title="Method returning an integer representing the first good bin specified in the header...">MuSR_td_PSI_bin::get_firstGood_int</a>(<span class="keywordtype">int</span> i)
<a name="l02968"></a>02968   {
<a name="l02969"></a>02969     <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l02970"></a>02970       <span class="keywordflow">return</span> -1 ;
<a name="l02971"></a>02971     <span class="keywordflow">else</span>
<a name="l02972"></a>02972       <span class="keywordflow">return</span> int(first_good[i]) ;
<a name="l02973"></a>02973   }
<a name="l02974"></a>02974 
<a name="l02975"></a>02975 
<a name="l02976"></a>02976 <span class="comment">//*******************************</span>
<a name="l02977"></a>02977 <span class="comment">//Implementation get_firstGood_vector</span>
<a name="l02978"></a>02978 <span class="comment">//*******************************</span>
<a name="l02979"></a>02979 
<a name="l02983"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a5464adeb75e8a5bb006c1066c557544d">02983</a>  vector&lt;int&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a5464adeb75e8a5bb006c1066c557544d" title="Method returning a vector of integer containing the first good bin values of the...">MuSR_td_PSI_bin::get_firstGood_vector</a>()
<a name="l02984"></a>02984   {
<a name="l02985"></a>02985     vector&lt;int&gt; firstGood(number_histo) ;
<a name="l02986"></a>02986 
<a name="l02987"></a>02987     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0 ; i &lt; number_histo ; i++ )
<a name="l02988"></a>02988       firstGood[i] = <span class="keywordtype">int</span>(first_good[i]) ;
<a name="l02989"></a>02989 
<a name="l02990"></a>02990     <span class="keywordflow">return</span> firstGood ;
<a name="l02991"></a>02991   }
<a name="l02992"></a>02992 
<a name="l02993"></a>02993 
<a name="l02994"></a>02994 <span class="comment">//*******************************</span>
<a name="l02995"></a>02995 <span class="comment">//Implementation put_firstGood_int</span>
<a name="l02996"></a>02996 <span class="comment">//*******************************</span>
<a name="l02997"></a>02997 
<a name="l03003"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae1cb1904f5c2e2e72ceff6e529eb1761">03003</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae1cb1904f5c2e2e72ceff6e529eb1761" title="Method to modify the first good bin (value &amp;lt;j&amp;gt;) of the histogram &amp;lt;i&amp;gt;...">MuSR_td_PSI_bin::put_firstGood_int</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
<a name="l03004"></a>03004   {
<a name="l03005"></a>03005     <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l03006"></a>03006       <span class="keywordflow">return</span> -1 ;
<a name="l03007"></a>03007     <span class="keywordflow">else</span>
<a name="l03008"></a>03008     {
<a name="l03009"></a>03009       first_good[i] = j ;
<a name="l03010"></a>03010       <span class="keywordflow">return</span>  0;
<a name="l03011"></a>03011     }
<a name="l03012"></a>03012   }
<a name="l03013"></a>03013 
<a name="l03014"></a>03014 
<a name="l03015"></a>03015 <span class="comment">//*******************************</span>
<a name="l03016"></a>03016 <span class="comment">//Implementation get_lastGood_int</span>
<a name="l03017"></a>03017 <span class="comment">//*******************************</span>
<a name="l03018"></a>03018 
<a name="l03024"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c">03024</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#abd44e4f041d5dec63fc81ca974a0ed5c" title="Method returning an integer representing the last good bin specified in the header...">MuSR_td_PSI_bin::get_lastGood_int</a>(<span class="keywordtype">int</span> i)
<a name="l03025"></a>03025   {
<a name="l03026"></a>03026     <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l03027"></a>03027       <span class="keywordflow">return</span> -1 ;
<a name="l03028"></a>03028     <span class="keywordflow">else</span>
<a name="l03029"></a>03029       <span class="keywordflow">return</span> int(last_good[i]) ;
<a name="l03030"></a>03030   }
<a name="l03031"></a>03031 
<a name="l03032"></a>03032 
<a name="l03033"></a>03033 <span class="comment">//*******************************</span>
<a name="l03034"></a>03034 <span class="comment">//Implementation get_lastGood_vector</span>
<a name="l03035"></a>03035 <span class="comment">//*******************************</span>
<a name="l03036"></a>03036 
<a name="l03040"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aae0f84e41e6525247c5b6ddcf5b694eb">03040</a>  vector&lt;int&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aae0f84e41e6525247c5b6ddcf5b694eb" title="Method returning a vector of integer containing the last good bin values of the histograms...">MuSR_td_PSI_bin::get_lastGood_vector</a>()
<a name="l03041"></a>03041   {
<a name="l03042"></a>03042     vector&lt;int&gt; lastGood(number_histo) ;
<a name="l03043"></a>03043 
<a name="l03044"></a>03044     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0 ; i &lt; number_histo ; i++ )
<a name="l03045"></a>03045       lastGood[i] = <span class="keywordtype">int</span>(last_good[i]) ;
<a name="l03046"></a>03046 
<a name="l03047"></a>03047     <span class="keywordflow">return</span> lastGood ;
<a name="l03048"></a>03048   }
<a name="l03049"></a>03049 
<a name="l03050"></a>03050 
<a name="l03051"></a>03051 <span class="comment">//*******************************</span>
<a name="l03052"></a>03052 <span class="comment">//Implementation get_max_lastGoog_int</span>
<a name="l03053"></a>03053 <span class="comment">//*******************************</span>
<a name="l03054"></a>03054 
<a name="l03058"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ab3d397137062650e8bfb1c1c953a007b">03058</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ab3d397137062650e8bfb1c1c953a007b" title="Method returning an integer containing the maximum value of the &amp;quot;last good bins&amp;quot;...">MuSR_td_PSI_bin::get_max_lastGood_int</a>()
<a name="l03059"></a>03059   {
<a name="l03060"></a>03060     <span class="keywordtype">int</span> max_lastGood = 0 ;
<a name="l03061"></a>03061 
<a name="l03062"></a>03062     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; int(number_histo) ; i++)
<a name="l03063"></a>03063     {
<a name="l03064"></a>03064       <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(last_good[i]) &gt; max_lastGood)
<a name="l03065"></a>03065         max_lastGood = <span class="keywordtype">int</span>(last_good[i]) ;
<a name="l03066"></a>03066     }
<a name="l03067"></a>03067 
<a name="l03068"></a>03068     <span class="keywordflow">return</span> max_lastGood ;
<a name="l03069"></a>03069   }
<a name="l03070"></a>03070 
<a name="l03071"></a>03071 
<a name="l03072"></a>03072 <span class="comment">//*******************************</span>
<a name="l03073"></a>03073 <span class="comment">//Implementation get_max_2_lastGood_int</span>
<a name="l03074"></a>03074 <span class="comment">//*******************************</span>
<a name="l03075"></a>03075 
<a name="l03081"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a967cabbdacb62111bf030856ef5adbc8">03081</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a967cabbdacb62111bf030856ef5adbc8" title="Method to determine the maximum value of the &amp;quot;last good bins&amp;quot; of 2 histograms...">MuSR_td_PSI_bin::get_max_2_lastGood_int</a>(<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j)
<a name="l03082"></a>03082   {
<a name="l03083"></a>03083     <span class="keywordflow">if</span> (( k &lt; 0 || k &gt;= <span class="keywordtype">int</span>(number_histo)) || ( j &lt; 0 || j &gt;= <span class="keywordtype">int</span>(number_histo)))
<a name="l03084"></a>03084       <span class="keywordflow">return</span> -1 ;
<a name="l03085"></a>03085     <span class="keywordflow">else</span>
<a name="l03086"></a>03086     {
<a name="l03087"></a>03087       <span class="keywordtype">int</span> max_lastGood = int(last_good[j]) ;
<a name="l03088"></a>03088 
<a name="l03089"></a>03089       <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(last_good[k]) &gt; max_lastGood)
<a name="l03090"></a>03090         max_lastGood = int(last_good[k]) ;
<a name="l03091"></a>03091 
<a name="l03092"></a>03092       <span class="keywordflow">return</span> max_lastGood ;
<a name="l03093"></a>03093     }
<a name="l03094"></a>03094   }
<a name="l03095"></a>03095 
<a name="l03096"></a>03096 
<a name="l03097"></a>03097 <span class="comment">//*******************************</span>
<a name="l03098"></a>03098 <span class="comment">//Implementation get_min_lastGood_int</span>
<a name="l03099"></a>03099 <span class="comment">//*******************************</span>
<a name="l03100"></a>03100 
<a name="l03104"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae6cc654ec6d5eddc652466d1db34fb6e">03104</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae6cc654ec6d5eddc652466d1db34fb6e" title="Method providing the minimum value of the last good bins.">MuSR_td_PSI_bin::get_min_lastGood_int</a>()
<a name="l03105"></a>03105   {
<a name="l03106"></a>03106     <span class="keywordtype">int</span> min_lastGood = int(last_good[0]) ;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1 ; i &lt; int(number_histo) ; i++)
<a name="l03109"></a>03109     {
<a name="l03110"></a>03110        <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(last_good[i]) &lt; min_lastGood)
<a name="l03111"></a>03111          min_lastGood = <span class="keywordtype">int</span>(last_good[i]) ;
<a name="l03112"></a>03112     }
<a name="l03113"></a>03113 
<a name="l03114"></a>03114     <span class="keywordflow">return</span> min_lastGood ;
<a name="l03115"></a>03115   }
<a name="l03116"></a>03116 
<a name="l03117"></a>03117 
<a name="l03118"></a>03118 <span class="comment">//*******************************</span>
<a name="l03119"></a>03119 <span class="comment">//Implementation get_min_2_lastGood_int</span>
<a name="l03120"></a>03120 <span class="comment">//*******************************</span>
<a name="l03121"></a>03121 
<a name="l03127"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#af2491db0c38cefb708aac4d86635ed06">03127</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#af2491db0c38cefb708aac4d86635ed06" title="Method to determine the minimum value of the last good bins of 2 histograms.">MuSR_td_PSI_bin::get_min_2_lastGood_int</a>(<span class="keywordtype">int</span> k, <span class="keywordtype">int</span> j)
<a name="l03128"></a>03128   {
<a name="l03129"></a>03129     <span class="keywordflow">if</span> (( k &lt; 0 || k &gt;= <span class="keywordtype">int</span>(number_histo)) || ( j &lt; 0 || j &gt;= <span class="keywordtype">int</span>(number_histo)))
<a name="l03130"></a>03130       <span class="keywordflow">return</span> -1 ;
<a name="l03131"></a>03131     <span class="keywordflow">else</span>
<a name="l03132"></a>03132     {
<a name="l03133"></a>03133        <span class="keywordtype">int</span> min_lastGood = int(last_good[j]) ;
<a name="l03134"></a>03134 
<a name="l03135"></a>03135        <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(last_good[k]) &lt; min_lastGood)
<a name="l03136"></a>03136          min_lastGood = int(last_good[k]) ;
<a name="l03137"></a>03137 
<a name="l03138"></a>03138        <span class="keywordflow">return</span> min_lastGood ;
<a name="l03139"></a>03139     }
<a name="l03140"></a>03140   }
<a name="l03141"></a>03141 
<a name="l03142"></a>03142 
<a name="l03143"></a>03143 <span class="comment">//*******************************</span>
<a name="l03144"></a>03144 <span class="comment">//Implementation put_lastGood_int</span>
<a name="l03145"></a>03145 <span class="comment">//*******************************</span>
<a name="l03146"></a>03146 
<a name="l03152"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad7cc1f87850e8c0caca38d3a4997d9a8">03152</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ad7cc1f87850e8c0caca38d3a4997d9a8" title="Method to modify the last good bin (value &amp;lt;j&amp;gt;) of the histogram &amp;lt;i&amp;gt;.">MuSR_td_PSI_bin::put_lastGood_int</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
<a name="l03153"></a>03153   {
<a name="l03154"></a>03154   <span class="keywordflow">if</span> ( i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l03155"></a>03155     <span class="keywordflow">return</span> -1 ;
<a name="l03156"></a>03156     <span class="keywordflow">else</span>
<a name="l03157"></a>03157     {
<a name="l03158"></a>03158        last_good[i] = j ;
<a name="l03159"></a>03159        <span class="keywordflow">return</span>  0;
<a name="l03160"></a>03160     }
<a name="l03161"></a>03161   }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163 
<a name="l03164"></a>03164 <span class="comment">//*******************************</span>
<a name="l03165"></a>03165 <span class="comment">//Implementation get_runNumber_int</span>
<a name="l03166"></a>03166 <span class="comment">//*******************************</span>
<a name="l03167"></a>03167 
<a name="l03171"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4a5e8aa009a39e1e7d2b29cc867ed9d5">03171</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4a5e8aa009a39e1e7d2b29cc867ed9d5" title="Method returning an integer containing the run number.">MuSR_td_PSI_bin::get_runNumber_int</a>()
<a name="l03172"></a>03172   {
<a name="l03173"></a>03173     <span class="keywordflow">return</span> int(num_run) ;
<a name="l03174"></a>03174   }
<a name="l03175"></a>03175 
<a name="l03176"></a>03176 
<a name="l03177"></a>03177 <span class="comment">//*******************************</span>
<a name="l03178"></a>03178 <span class="comment">//Implementation put_runNumber_int</span>
<a name="l03179"></a>03179 <span class="comment">//*******************************</span>
<a name="l03180"></a>03180 
<a name="l03186"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#af6f44d04cca9db32c6139dc0d9eac04a">03186</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#af6f44d04cca9db32c6139dc0d9eac04a" title="Method to modify the run number (value &amp;lt;i&amp;gt;).">MuSR_td_PSI_bin::put_runNumber_int</a>(<span class="keywordtype">int</span> i)
<a name="l03187"></a>03187   {
<a name="l03188"></a>03188     <span class="keywordflow">if</span> (i &lt;= 0 )
<a name="l03189"></a>03189       <span class="keywordflow">return</span> -1 ;
<a name="l03190"></a>03190     <span class="keywordflow">else</span>
<a name="l03191"></a>03191       num_run = i ;
<a name="l03192"></a>03192     <span class="keywordflow">return</span> 0 ;
<a name="l03193"></a>03193   }
<a name="l03194"></a>03194 
<a name="l03195"></a>03195 
<a name="l03196"></a>03196 <span class="comment">//*******************************</span>
<a name="l03197"></a>03197 <span class="comment">//Implementation get_sample()</span>
<a name="l03198"></a>03198 <span class="comment">//*******************************</span>
<a name="l03199"></a>03199 
<a name="l03203"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a093128c3c2333ccf41c976ad09979c0c">03203</a>  <span class="keywordtype">string</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a093128c3c2333ccf41c976ad09979c0c" title="Method returning a string containing the sample name.">MuSR_td_PSI_bin::get_sample</a>()
<a name="l03204"></a>03204   {
<a name="l03205"></a>03205     <span class="keywordtype">string</span> strData ;
<a name="l03206"></a>03206 
<a name="l03207"></a>03207     strData = sample ;
<a name="l03208"></a>03208 
<a name="l03209"></a>03209     <span class="keywordflow">return</span> strData ;
<a name="l03210"></a>03210   }
<a name="l03211"></a>03211 
<a name="l03212"></a>03212 
<a name="l03213"></a>03213 <span class="comment">//*******************************</span>
<a name="l03214"></a>03214 <span class="comment">//Implementation get_temp()</span>
<a name="l03215"></a>03215 <span class="comment">//*******************************</span>
<a name="l03216"></a>03216 
<a name="l03220"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a1f7dffa591d669671050d4c1ddf772fd">03220</a>  <span class="keywordtype">string</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a1f7dffa591d669671050d4c1ddf772fd" title="Method returning a string containing the temperature specified in the title.">MuSR_td_PSI_bin::get_temp</a>()
<a name="l03221"></a>03221   {
<a name="l03222"></a>03222     <span class="keywordtype">string</span> strData ;
<a name="l03223"></a>03223 
<a name="l03224"></a>03224     strData = temp ;
<a name="l03225"></a>03225 
<a name="l03226"></a>03226     <span class="keywordflow">return</span> strData ;
<a name="l03227"></a>03227   }
<a name="l03228"></a>03228 
<a name="l03229"></a>03229 
<a name="l03230"></a>03230 <span class="comment">//*******************************</span>
<a name="l03231"></a>03231 <span class="comment">//Implementation get_orient()</span>
<a name="l03232"></a>03232 <span class="comment">//*******************************</span>
<a name="l03233"></a>03233 
<a name="l03237"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ab3397f8a328092ef4acd81abfc645abe">03237</a>  <span class="keywordtype">string</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ab3397f8a328092ef4acd81abfc645abe" title="Method returning a string containing the orientation specified in the title.">MuSR_td_PSI_bin::get_orient</a>()
<a name="l03238"></a>03238   {
<a name="l03239"></a>03239     <span class="keywordtype">string</span> strData ;
<a name="l03240"></a>03240 
<a name="l03241"></a>03241     strData = orient ;
<a name="l03242"></a>03242 
<a name="l03243"></a>03243     <span class="keywordflow">return</span> strData ;
<a name="l03244"></a>03244   }
<a name="l03245"></a>03245 
<a name="l03246"></a>03246 
<a name="l03247"></a>03247 <span class="comment">//*******************************</span>
<a name="l03248"></a>03248 <span class="comment">//Implementation get_field()</span>
<a name="l03249"></a>03249 <span class="comment">//*******************************</span>
<a name="l03250"></a>03250 
<a name="l03254"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a0dda377dcae374bf5f3d864f06a37515">03254</a>  <span class="keywordtype">string</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a0dda377dcae374bf5f3d864f06a37515" title="Method returning a string containing the field specified in the title.">MuSR_td_PSI_bin::get_field</a>()
<a name="l03255"></a>03255   {
<a name="l03256"></a>03256     <span class="keywordtype">string</span> strData ;
<a name="l03257"></a>03257 
<a name="l03258"></a>03258     strData = field ;
<a name="l03259"></a>03259 
<a name="l03260"></a>03260     <span class="keywordflow">return</span> strData ;
<a name="l03261"></a>03261   }
<a name="l03262"></a>03262 
<a name="l03263"></a>03263 
<a name="l03264"></a>03264 <span class="comment">//*******************************</span>
<a name="l03265"></a>03265 <span class="comment">//Implementation get_comments()</span>
<a name="l03266"></a>03266 <span class="comment">//*******************************</span>
<a name="l03267"></a>03267 
<a name="l03271"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a5e2d1c7371f3c3f0f8d5a1003cfad0df">03271</a>  <span class="keywordtype">string</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a5e2d1c7371f3c3f0f8d5a1003cfad0df" title="Method returning a string containing the comment specified in the title.">MuSR_td_PSI_bin::get_comment</a>()
<a name="l03272"></a>03272   {
<a name="l03273"></a>03273     <span class="keywordtype">string</span> strData ;
<a name="l03274"></a>03274 
<a name="l03275"></a>03275     strData = comment ;
<a name="l03276"></a>03276 
<a name="l03277"></a>03277     <span class="keywordflow">return</span> strData ;
<a name="l03278"></a>03278   }
<a name="l03279"></a>03279 
<a name="l03280"></a>03280 
<a name="l03281"></a>03281 <span class="comment">//*******************************</span>
<a name="l03282"></a>03282 <span class="comment">//Implementation get_nameHisto()</span>
<a name="l03283"></a>03283 <span class="comment">//*******************************</span>
<a name="l03284"></a>03284 
<a name="l03290"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afdc412fd6cb2191588a66eab40cc4908">03290</a>  <span class="keywordtype">string</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#afdc412fd6cb2191588a66eab40cc4908" title="Method returning a string containing the name of the histogram &amp;lt;i&amp;gt;.">MuSR_td_PSI_bin::get_nameHisto</a>(<span class="keywordtype">int</span> i)
<a name="l03291"></a>03291   {
<a name="l03292"></a>03292     <span class="keywordtype">string</span> strData ;
<a name="l03293"></a>03293 
<a name="l03294"></a>03294     <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= <span class="keywordtype">int</span>(number_histo))
<a name="l03295"></a>03295       <span class="keywordflow">return</span> NULL ;
<a name="l03296"></a>03296     <span class="keywordflow">else</span>
<a name="l03297"></a>03297     {
<a name="l03298"></a>03298       strData = labels_histo[i] ;
<a name="l03299"></a>03299       <span class="keywordflow">return</span> strData ;
<a name="l03300"></a>03300     }
<a name="l03301"></a>03301   }
<a name="l03302"></a>03302 
<a name="l03303"></a>03303 
<a name="l03304"></a>03304 <span class="comment">//*******************************</span>
<a name="l03305"></a>03305 <span class="comment">//Implementation get_histoNames_vector()</span>
<a name="l03306"></a>03306 <span class="comment">//*******************************</span>
<a name="l03307"></a>03307 
<a name="l03311"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aeb658999fefcbd4394fd5b4b7cac2528">03311</a>  vector&lt;string&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aeb658999fefcbd4394fd5b4b7cac2528" title="Method returning a vector of strings containing the names of the histograms.">MuSR_td_PSI_bin::get_histoNames_vector</a>()
<a name="l03312"></a>03312   {
<a name="l03313"></a>03313     vector &lt;string&gt; str_Vector ;
<a name="l03314"></a>03314 
<a name="l03315"></a>03315     <span class="keywordtype">string</span> strData ;
<a name="l03316"></a>03316     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; number_histo ; i++)
<a name="l03317"></a>03317     {
<a name="l03318"></a>03318       strData = labels_histo[i] ;
<a name="l03319"></a>03319       str_Vector.push_back(strData) ;
<a name="l03320"></a>03320     }
<a name="l03321"></a>03321 
<a name="l03322"></a>03322     <span class="keywordflow">return</span> str_Vector;
<a name="l03323"></a>03323   }
<a name="l03324"></a>03324 
<a name="l03325"></a>03325 
<a name="l03326"></a>03326 <span class="comment">//*******************************</span>
<a name="l03327"></a>03327 <span class="comment">//Implementation get_scalersNames_vector()</span>
<a name="l03328"></a>03328 <span class="comment">//*******************************</span>
<a name="l03329"></a>03329 
<a name="l03333"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#acb3ccc6737ece39f8736a15ebb35f17c">03333</a>  vector&lt;string&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#acb3ccc6737ece39f8736a15ebb35f17c" title="Method returning a vector of strings containing the names of the scalers.">MuSR_td_PSI_bin::get_scalersNames_vector</a>()
<a name="l03334"></a>03334   {
<a name="l03335"></a>03335     vector &lt;string&gt; str_Vector ;
<a name="l03336"></a>03336 
<a name="l03337"></a>03337     <span class="keywordtype">string</span> strData ;
<a name="l03338"></a>03338     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; number_scaler ; i++)
<a name="l03339"></a>03339     {
<a name="l03340"></a>03340       strData = labels_scalers[i] ;
<a name="l03341"></a>03341       str_Vector.push_back(strData) ;
<a name="l03342"></a>03342     }
<a name="l03343"></a>03343 
<a name="l03344"></a>03344     <span class="keywordflow">return</span> str_Vector;
<a name="l03345"></a>03345   }
<a name="l03346"></a>03346 
<a name="l03347"></a>03347 
<a name="l03348"></a>03348 <span class="comment">//*******************************</span>
<a name="l03349"></a>03349 <span class="comment">//Implementation get_numberTemperature_int</span>
<a name="l03350"></a>03350 <span class="comment">//*******************************</span>
<a name="l03351"></a>03351 
<a name="l03355"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a226483328110f7a4ffd85766b060b4c8">03355</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a226483328110f7a4ffd85766b060b4c8" title="Method returning an integer representing the number of temperatures.">MuSR_td_PSI_bin::get_numberTemperature_int</a>()
<a name="l03356"></a>03356   {
<a name="l03357"></a>03357     <span class="keywordflow">return</span> int(number_temper) ;
<a name="l03358"></a>03358   }
<a name="l03359"></a>03359 
<a name="l03360"></a>03360 <span class="comment">//*******************************</span>
<a name="l03361"></a>03361 <span class="comment">//Implementation get_temperatures_vector()</span>
<a name="l03362"></a>03362 <span class="comment">//*******************************</span>
<a name="l03363"></a>03363 
<a name="l03367"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae71e99d6d0f73f28180934d326577ba5">03367</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae71e99d6d0f73f28180934d326577ba5" title="Method returning a vector of doubles containing monitored values (usually temperatures)...">MuSR_td_PSI_bin::get_temperatures_vector</a>()
<a name="l03368"></a>03368   {
<a name="l03369"></a>03369      vector &lt;double&gt; dbl_Temper ;
<a name="l03370"></a>03370 
<a name="l03371"></a>03371      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; number_temper ; i++)
<a name="l03372"></a>03372      {
<a name="l03373"></a>03373         dbl_Temper.push_back(<span class="keywordtype">double</span>(temper[i])) ;
<a name="l03374"></a>03374      }
<a name="l03375"></a>03375 
<a name="l03376"></a>03376      <span class="keywordflow">return</span> dbl_Temper;
<a name="l03377"></a>03377   }
<a name="l03378"></a>03378 
<a name="l03379"></a>03379 <span class="comment">//*******************************</span>
<a name="l03380"></a>03380 <span class="comment">//Implementation get_devTemperatures_vector()</span>
<a name="l03381"></a>03381 <span class="comment">//*******************************</span>
<a name="l03382"></a>03382 
<a name="l03386"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aa0e836825fb67289eca1e029bf42da65">03386</a>  vector&lt;double&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#aa0e836825fb67289eca1e029bf42da65" title="Method returning a vector of doubles containing standard deviations of the monitored...">MuSR_td_PSI_bin::get_devTemperatures_vector</a>()
<a name="l03387"></a>03387   {
<a name="l03388"></a>03388      vector &lt;double&gt; dbl_devTemper ;
<a name="l03389"></a>03389 
<a name="l03390"></a>03390      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; number_temper ; i++)
<a name="l03391"></a>03391      {
<a name="l03392"></a>03392         dbl_devTemper.push_back(<span class="keywordtype">double</span>(temp_deviation[i])) ;
<a name="l03393"></a>03393      }
<a name="l03394"></a>03394 
<a name="l03395"></a>03395      <span class="keywordflow">return</span> dbl_devTemper;
<a name="l03396"></a>03396   }
<a name="l03397"></a>03397 
<a name="l03398"></a>03398 <span class="comment">//*******************************</span>
<a name="l03399"></a>03399 <span class="comment">//Implementation get_timeStart_vector()</span>
<a name="l03400"></a>03400 <span class="comment">//*******************************</span>
<a name="l03401"></a>03401 
<a name="l03406"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae30eadc13ca9692149d8efbdfa2756d9">03406</a>  vector&lt;string&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#ae30eadc13ca9692149d8efbdfa2756d9" title="Method returning a vector of strings containing 1) the date when the run was started...">MuSR_td_PSI_bin::get_timeStart_vector</a>()
<a name="l03407"></a>03407 
<a name="l03408"></a>03408   {
<a name="l03409"></a>03409     vector&lt;string&gt; timeStart(2) ;
<a name="l03410"></a>03410 
<a name="l03411"></a>03411     timeStart[0] = date_start ;
<a name="l03412"></a>03412     timeStart[1] = time_start ;
<a name="l03413"></a>03413 
<a name="l03414"></a>03414     <span class="keywordflow">return</span> timeStart ;
<a name="l03415"></a>03415   }
<a name="l03416"></a>03416 
<a name="l03417"></a>03417 
<a name="l03418"></a>03418 <span class="comment">//*******************************</span>
<a name="l03419"></a>03419 <span class="comment">//Implementation get_timeStop_vector()</span>
<a name="l03420"></a>03420 <span class="comment">//*******************************</span>
<a name="l03421"></a>03421 
<a name="l03426"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4c07d52f9773cadabe44d967169f552a">03426</a>  vector&lt;string&gt; <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a4c07d52f9773cadabe44d967169f552a" title="Method returning a vector of strings containing 1) the date when the run was stopped...">MuSR_td_PSI_bin::get_timeStop_vector</a>()
<a name="l03427"></a>03427 
<a name="l03428"></a>03428   {
<a name="l03429"></a>03429     vector&lt;string&gt; timeStop(2) ;
<a name="l03430"></a>03430 
<a name="l03431"></a>03431     timeStop[0] = date_stop ;
<a name="l03432"></a>03432     timeStop[1] = time_stop ;
<a name="l03433"></a>03433 
<a name="l03434"></a>03434     <span class="keywordflow">return</span> timeStop ;
<a name="l03435"></a>03435   }
<a name="l03436"></a>03436 
<a name="l03437"></a>03437 <span class="comment">//*******************************</span>
<a name="l03438"></a>03438 <span class="comment">//Implementation Clear()</span>
<a name="l03439"></a>03439 <span class="comment">//*******************************</span>
<a name="l03440"></a>03440 
<a name="l03444"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a">03444</a>  <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a570eddb99f4424647b86a6c3bf57967a" title="Method to clear member variables before using instance for next read.">MuSR_td_PSI_bin::Clear</a>()
<a name="l03445"></a>03445 
<a name="l03446"></a>03446   {
<a name="l03447"></a>03447     <span class="keywordtype">int</span> i,j;
<a name="l03448"></a>03448 
<a name="l03449"></a>03449    <span class="comment">// NIY maybe flag when histo should not be released</span>
<a name="l03450"></a>03450 
<a name="l03451"></a>03451     <span class="comment">// free private histograms</span>
<a name="l03452"></a>03452     <span class="keywordflow">if</span> (histo != NULL)
<a name="l03453"></a>03453     {
<a name="l03454"></a>03454         <span class="keywordflow">for</span> (i=0; i &lt; number_histo; i++)
<a name="l03455"></a>03455           <span class="keywordflow">if</span> (*(histo+i) != NULL)
<a name="l03456"></a>03456           {
<a name="l03457"></a>03457             <span class="keyword">delete</span>[] *(histo+i);
<a name="l03458"></a>03458             *(histo+i) = NULL;
<a name="l03459"></a>03459           }
<a name="l03460"></a>03460         <span class="keyword">delete</span> [] histo;
<a name="l03461"></a>03461         histo = NULL;
<a name="l03462"></a>03462     }
<a name="l03463"></a>03463 
<a name="l03464"></a>03464     <span class="comment">// free public vector</span>
<a name="l03465"></a>03465     <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#a49f45e4f13e0be563b062e0d5c67187e">histos_vector</a>.clear();
<a name="l03466"></a>03466 
<a name="l03467"></a>03467     <span class="comment">// init other member variables</span>
<a name="l03468"></a>03468     filename  = <span class="stringliteral">&quot;?&quot;</span>;
<a name="l03469"></a>03469     readingok = <span class="keyword">false</span>;
<a name="l03470"></a>03470     readstatus  = <span class="stringliteral">&quot;&quot;</span>;
<a name="l03471"></a>03471 
<a name="l03472"></a>03472     strcpy(format_id,<span class="stringliteral">&quot;??&quot;</span>);
<a name="l03473"></a>03473 
<a name="l03474"></a>03474     num_run = 0;
<a name="l03475"></a>03475                      <span class="comment">//01234567890</span>
<a name="l03476"></a>03476     strcpy(sample,    <span class="stringliteral">&quot;          &quot;</span>);
<a name="l03477"></a>03477     strcpy(temp,      <span class="stringliteral">&quot;          &quot;</span>);
<a name="l03478"></a>03478     strcpy(field,     <span class="stringliteral">&quot;          &quot;</span>);
<a name="l03479"></a>03479     strcpy(orient,    <span class="stringliteral">&quot;          &quot;</span>);
<a name="l03480"></a>03480     strcpy(comment,   <span class="stringliteral">&quot;          &quot;</span>);
<a name="l03481"></a>03481     strcpy(date_start,<span class="stringliteral">&quot;         &quot;</span>);
<a name="l03482"></a>03482     strcpy(time_start,<span class="stringliteral">&quot;        &quot;</span>);
<a name="l03483"></a>03483     strcpy(date_stop, <span class="stringliteral">&quot;         &quot;</span>);
<a name="l03484"></a>03484     strcpy(time_stop, <span class="stringliteral">&quot;        &quot;</span>);
<a name="l03485"></a>03485 
<a name="l03486"></a>03486     bin_width = 0.f;
<a name="l03487"></a>03487     number_histo = 0;
<a name="l03488"></a>03488     length_histo = 0;
<a name="l03489"></a>03489     total_events = 0;
<a name="l03490"></a>03490     default_binning = 1;
<a name="l03491"></a>03491 
<a name="l03492"></a>03492     <span class="keywordflow">for</span> (i=0; i &lt; MAXHISTO; i++)
<a name="l03493"></a>03493     {
<a name="l03494"></a>03494       <span class="keywordflow">for</span> (j=0; j &lt; MAXLABELSIZE-1; j++)
<a name="l03495"></a>03495         labels_histo[i][j] = <span class="charliteral">&apos; &apos;</span>;
<a name="l03496"></a>03496       labels_histo[i][MAXLABELSIZE-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l03497"></a>03497       events_per_histo[i] = 0;
<a name="l03498"></a>03498       real_t0[i]    = 0.f;
<a name="l03499"></a>03499       integer_t0[i] = 0;
<a name="l03500"></a>03500       first_good[i] = 0;
<a name="l03501"></a>03501       last_good[i]  = 0;
<a name="l03502"></a>03502     }
<a name="l03503"></a>03503 
<a name="l03504"></a>03504     number_scaler = 0;
<a name="l03505"></a>03505     <span class="keywordflow">for</span> (i=0; i &lt; MAXSCALER; i++)
<a name="l03506"></a>03506     {
<a name="l03507"></a>03507       <span class="keywordflow">for</span> (j=0; j &lt; MAXLABELSIZE-1; j++)
<a name="l03508"></a>03508         labels_scalers[i][j] = <span class="charliteral">&apos; &apos;</span>;
<a name="l03509"></a>03509       labels_scalers[i][MAXLABELSIZE-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l03510"></a>03510 
<a name="l03511"></a>03511       scalers[i] = 0;
<a name="l03512"></a>03512     }
<a name="l03513"></a>03513 
<a name="l03514"></a>03514     number_temper = 0;
<a name="l03515"></a>03515     <span class="keywordflow">for</span> (i=0; i &lt; MAXTEMPER; i++)
<a name="l03516"></a>03516     {
<a name="l03517"></a>03517       temper[i] = 0.f;
<a name="l03518"></a>03518       temp_deviation[i] = 0.f;
<a name="l03519"></a>03519     }
<a name="l03520"></a>03520 
<a name="l03521"></a>03521     <span class="keywordflow">return</span> 0;
<a name="l03522"></a>03522   }
<a name="l03523"></a>03523 
<a name="l03524"></a>03524 <span class="comment">//*******************************</span>
<a name="l03525"></a>03525 <span class="comment">//Implementation Show()</span>
<a name="l03526"></a>03526 <span class="comment">//*******************************</span>
<a name="l03530"></a><a class="code" href="class_mu_s_r__td___p_s_i__bin.html#acbe1e325e70837d75c5d29dca71f49f8">03530</a> <span class="comment"></span> <span class="keywordtype">int</span> <a class="code" href="class_mu_s_r__td___p_s_i__bin.html#acbe1e325e70837d75c5d29dca71f49f8" title="Method to show current values of member variables.">MuSR_td_PSI_bin::Show</a>()<span class="keyword">          const</span>
<a name="l03531"></a>03531 <span class="keyword"></span>
<a name="l03532"></a>03532 <span class="keyword">  </span>{
<a name="l03533"></a>03533     cout &lt;&lt; <span class="stringliteral">&quot;Filename is &quot;</span> &lt;&lt; filename &lt;&lt; endl;
<a name="l03534"></a>03534     <span class="keywordflow">if</span> (readingok) {
<a name="l03535"></a>03535       <span class="keywordtype">int</span> i;
<a name="l03536"></a>03536 
<a name="l03537"></a>03537       cout &lt;&lt; <span class="stringliteral">&quot;Format Identifier is &quot;</span> &lt;&lt; format_id &lt;&lt; endl;
<a name="l03538"></a>03538 
<a name="l03539"></a>03539       cout &lt;&lt; <span class="stringliteral">&quot;Run number is  &quot;</span> &lt;&lt; num_run &lt;&lt; endl;
<a name="l03540"></a>03540       cout &lt;&lt; <span class="stringliteral">&quot;Sample is      &quot;</span> &lt;&lt; sample  &lt;&lt; endl;
<a name="l03541"></a>03541       cout &lt;&lt; <span class="stringliteral">&quot;Temperature is &quot;</span> &lt;&lt; temp    &lt;&lt; endl;
<a name="l03542"></a>03542       cout &lt;&lt; <span class="stringliteral">&quot;Field is       &quot;</span> &lt;&lt; field   &lt;&lt; endl;
<a name="l03543"></a>03543       cout &lt;&lt; <span class="stringliteral">&quot;Orientation is &quot;</span> &lt;&lt; orient  &lt;&lt; endl;
<a name="l03544"></a>03544       cout &lt;&lt; <span class="stringliteral">&quot;Comment is     &quot;</span> &lt;&lt; comment &lt;&lt; endl;
<a name="l03545"></a>03545 
<a name="l03546"></a>03546       cout &lt;&lt; <span class="stringliteral">&quot;Start Date is  &quot;</span> &lt;&lt; date_start &lt;&lt; endl;
<a name="l03547"></a>03547       cout &lt;&lt; <span class="stringliteral">&quot;Start Time is  &quot;</span> &lt;&lt; time_start &lt;&lt; endl;
<a name="l03548"></a>03548 
<a name="l03549"></a>03549       cout &lt;&lt; <span class="stringliteral">&quot;End Date is    &quot;</span> &lt;&lt; date_stop &lt;&lt; endl;
<a name="l03550"></a>03550       cout &lt;&lt; <span class="stringliteral">&quot;End Time is    &quot;</span> &lt;&lt; time_stop &lt;&lt; endl;
<a name="l03551"></a>03551 
<a name="l03552"></a>03552       cout &lt;&lt; <span class="stringliteral">&quot;Bin width is   &quot;</span> &lt;&lt; bin_width &lt;&lt; <span class="stringliteral">&quot; [usec]&quot;</span> &lt;&lt; endl;
<a name="l03553"></a>03553       cout &lt;&lt; <span class="stringliteral">&quot;Number of histograms is &quot;</span> &lt;&lt; number_histo &lt;&lt; endl;
<a name="l03554"></a>03554       cout &lt;&lt; <span class="stringliteral">&quot;Histogram length is     &quot;</span> &lt;&lt; length_histo &lt;&lt; endl;
<a name="l03555"></a>03555       cout &lt;&lt; <span class="stringliteral">&quot;Default binning is      &quot;</span> &lt;&lt; default_binning &lt;&lt; endl;
<a name="l03556"></a>03556       cout &lt;&lt; <span class="stringliteral">&quot;Total number of events is &quot;</span> &lt;&lt; total_events &lt;&lt; endl;
<a name="l03557"></a>03557 
<a name="l03558"></a>03558       <span class="keywordflow">for</span> (i=0; i &lt; number_histo; i++) {
<a name="l03559"></a>03559         cout &lt;&lt; <span class="stringliteral">&quot;Histogram &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; Name is &gt;&quot;</span> &lt;&lt; labels_histo[i]
<a name="l03560"></a>03560              &lt;&lt; <span class="stringliteral">&quot;&lt;  Events per histogram is &quot;</span> &lt;&lt; events_per_histo[i] &lt;&lt; endl;
<a name="l03561"></a>03561         cout &lt;&lt; <span class="stringliteral">&quot;      real t0 is              &quot;</span> &lt;&lt; real_t0[i] &lt;&lt; endl;
<a name="l03562"></a>03562         cout &lt;&lt; <span class="stringliteral">&quot;      t0 is                   &quot;</span> &lt;&lt; integer_t0[i] &lt;&lt; endl;
<a name="l03563"></a>03563         cout &lt;&lt; <span class="stringliteral">&quot;      first good bin is       &quot;</span> &lt;&lt; first_good[i] &lt;&lt; endl;
<a name="l03564"></a>03564         cout &lt;&lt; <span class="stringliteral">&quot;      last good bin is        &quot;</span> &lt;&lt; last_good[i] &lt;&lt; endl;
<a name="l03565"></a>03565       }
<a name="l03566"></a>03566 
<a name="l03567"></a>03567       cout &lt;&lt; <span class="stringliteral">&quot;Number of scalers is &quot;</span> &lt;&lt; number_scaler &lt;&lt; endl;
<a name="l03568"></a>03568       <span class="keywordflow">for</span> (i=0; i &lt; number_scaler; i++) {
<a name="l03569"></a>03569         cout &lt;&lt; <span class="stringliteral">&quot;Scaler &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; Name is &gt;&quot;</span> &lt;&lt; labels_scalers[i]
<a name="l03570"></a>03570              &lt;&lt; <span class="stringliteral">&quot;&lt;   Value is &quot;</span> &lt;&lt; scalers[i] &lt;&lt; endl;
<a name="l03571"></a>03571       }
<a name="l03572"></a>03572 
<a name="l03573"></a>03573       cout &lt;&lt; <span class="stringliteral">&quot;Number of temperatures is &quot;</span> &lt;&lt; number_temper &lt;&lt; endl;
<a name="l03574"></a>03574       <span class="keywordflow">for</span> (i=0; i &lt; number_temper; i++) {
<a name="l03575"></a>03575         cout &lt;&lt; <span class="stringliteral">&quot;Temperature &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; temper[i]
<a name="l03576"></a>03576              &lt;&lt; <span class="stringliteral">&quot;   Deviation is &quot;</span> &lt;&lt; temp_deviation[i] &lt;&lt; endl;
<a name="l03577"></a>03577       }
<a name="l03578"></a>03578 
<a name="l03579"></a>03579     } <span class="keywordflow">else</span> {
<a name="l03580"></a>03580       cout &lt;&lt; readstatus &lt;&lt; endl;
<a name="l03581"></a>03581     }
<a name="l03582"></a>03582    <span class="keywordflow">return</span> 0;
<a name="l03583"></a>03583   }
<a name="l03584"></a>03584 
<a name="l03585"></a>03585 
<a name="l03586"></a>03586 <span class="comment">//*******************************</span>
<a name="l03587"></a>03587 <span class="comment">//Implementation tmax</span>
<a name="l03588"></a>03588 <span class="comment">//*******************************</span>
<a name="l03589"></a>03589 
<a name="l03590"></a>03590  <span class="keywordtype">int</span> MuSR_td_PSI_bin::tmax(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l03591"></a>03591   {
<a name="l03592"></a>03592      <span class="keywordflow">if</span> (x &gt;= y)
<a name="l03593"></a>03593      {
<a name="l03594"></a>03594          <span class="keywordflow">return</span> x ;
<a name="l03595"></a>03595      }
<a name="l03596"></a>03596      <span class="keywordflow">return</span> y ;
<a name="l03597"></a>03597   }
<a name="l03598"></a>03598 
<a name="l03599"></a>03599 
<a name="l03600"></a>03600 <span class="comment">//*******************************</span>
<a name="l03601"></a>03601 <span class="comment">//Implementation tmin</span>
<a name="l03602"></a>03602 <span class="comment">//*******************************</span>
<a name="l03603"></a>03603 
<a name="l03604"></a>03604  <span class="keywordtype">int</span> MuSR_td_PSI_bin::tmin(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l03605"></a>03605   {
<a name="l03606"></a>03606      <span class="keywordflow">if</span> (x &gt;= y)
<a name="l03607"></a>03607      {
<a name="l03608"></a>03608          <span class="keywordflow">return</span> y ;
<a name="l03609"></a>03609      }
<a name="l03610"></a>03610      <span class="keywordflow">return</span> x ;
<a name="l03611"></a>03611   }
<a name="l03612"></a>03612 
<a name="l03613"></a>03613 <span class="comment">/************************************************************************************</span>
<a name="l03614"></a>03614 <span class="comment"> * EOF MuSR_td_PSI_bin.cpp                                                       *</span>
<a name="l03615"></a>03615 <span class="comment"> ************************************************************************************/</span>
<a name="l03616"></a>03616 
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 27 14:32:29 2009 for Class MuSR_td_PSI_bin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
